// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usb_comm.proto

#include "usb_comm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace usb {
namespace comm {
PROTOBUF_CONSTEXPR MessageH2D::MessageH2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MessageH2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageH2DDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageH2DDefaultTypeInternal() {}
  union {
    MessageH2D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageH2DDefaultTypeInternal _MessageH2D_default_instance_;
PROTOBUF_CONSTEXPR MessageD2H::MessageD2H(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MessageD2HDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageD2HDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageD2HDefaultTypeInternal() {}
  union {
    MessageD2H _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageD2HDefaultTypeInternal _MessageD2H_default_instance_;
PROTOBUF_CONSTEXPR Nop::Nop(
    ::_pbi::ConstantInitialized) {}
struct NopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NopDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NopDefaultTypeInternal() {}
  union {
    Nop _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NopDefaultTypeInternal _Nop_default_instance_;
PROTOBUF_CONSTEXPR Version_Features::Version_Features(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rgb_)*/false
  , /*decltype(_impl_.rgb_full_control_)*/false
  , /*decltype(_impl_.rgb_indicator_)*/false
  , /*decltype(_impl_.eink_)*/false
  , /*decltype(_impl_.knob_)*/false
  , /*decltype(_impl_.knob_prefs_)*/false} {}
struct Version_FeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Version_FeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Version_FeaturesDefaultTypeInternal() {}
  union {
    Version_Features _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Version_FeaturesDefaultTypeInternal _Version_Features_default_instance_;
PROTOBUF_CONSTEXPR Version::Version(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.zephyr_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.zmk_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.features_)*/nullptr} {}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
PROTOBUF_CONSTEXPR MotorState::MotorState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.control_mode_)*/0
  , /*decltype(_impl_.current_angle_)*/0
  , /*decltype(_impl_.current_velocity_)*/0
  , /*decltype(_impl_.target_angle_)*/0
  , /*decltype(_impl_.target_velocity_)*/0
  , /*decltype(_impl_.target_voltage_)*/0} {}
struct MotorStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MotorStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MotorStateDefaultTypeInternal() {}
  union {
    MotorState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MotorStateDefaultTypeInternal _MotorState_default_instance_;
PROTOBUF_CONSTEXPR KnobConfig_Pref::KnobConfig_Pref(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.layer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.layer_id_)*/0u
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_.ppr_)*/0u
  , /*decltype(_impl_.torque_limit_)*/0} {}
struct KnobConfig_PrefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KnobConfig_PrefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KnobConfig_PrefDefaultTypeInternal() {}
  union {
    KnobConfig_Pref _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KnobConfig_PrefDefaultTypeInternal _KnobConfig_Pref_default_instance_;
PROTOBUF_CONSTEXPR KnobConfig::KnobConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prefs_)*/{}
  , /*decltype(_impl_.demo_)*/false
  , /*decltype(_impl_.mode_)*/0} {}
struct KnobConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KnobConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KnobConfigDefaultTypeInternal() {}
  union {
    KnobConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KnobConfigDefaultTypeInternal _KnobConfig_default_instance_;
PROTOBUF_CONSTEXPR RgbControl::RgbControl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/1} {}
struct RgbControlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RgbControlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RgbControlDefaultTypeInternal() {}
  union {
    RgbControl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RgbControlDefaultTypeInternal _RgbControl_default_instance_;
PROTOBUF_CONSTEXPR RgbState_HSB::RgbState_HSB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.h_)*/0u
  , /*decltype(_impl_.s_)*/0u
  , /*decltype(_impl_.b_)*/0u} {}
struct RgbState_HSBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RgbState_HSBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RgbState_HSBDefaultTypeInternal() {}
  union {
    RgbState_HSB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RgbState_HSBDefaultTypeInternal _RgbState_HSB_default_instance_;
PROTOBUF_CONSTEXPR RgbState::RgbState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.on_)*/false
  , /*decltype(_impl_.effect_)*/0
  , /*decltype(_impl_.speed_)*/0u} {}
struct RgbStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RgbStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RgbStateDefaultTypeInternal() {}
  union {
    RgbState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RgbStateDefaultTypeInternal _RgbState_default_instance_;
PROTOBUF_CONSTEXPR RgbIndicator::RgbIndicator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_)*/false
  , /*decltype(_impl_.brightness_active_)*/0u
  , /*decltype(_impl_.brightness_inactive_)*/0u} {}
struct RgbIndicatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RgbIndicatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RgbIndicatorDefaultTypeInternal() {}
  union {
    RgbIndicator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RgbIndicatorDefaultTypeInternal _RgbIndicator_default_instance_;
PROTOBUF_CONSTEXPR EinkImage::EinkImage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bits_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.bits_length_)*/0u} {}
struct EinkImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EinkImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EinkImageDefaultTypeInternal() {}
  union {
    EinkImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EinkImageDefaultTypeInternal _EinkImage_default_instance_;
}  // namespace comm
}  // namespace usb
static ::_pb::Metadata file_level_metadata_usb_5fcomm_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_usb_5fcomm_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_usb_5fcomm_2eproto = nullptr;

const uint32_t TableStruct_usb_5fcomm_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageH2D, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageH2D, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageH2D, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageH2D, _impl_.action_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageH2D, _impl_.payload_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageD2H, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageD2H, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageD2H, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageD2H, _impl_.action_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::usb::comm::MessageD2H, _impl_.payload_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::usb::comm::Nop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_.rgb_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_.rgb_full_control_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_.rgb_indicator_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_.eink_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_.knob_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version_Features, _impl_.knob_prefs_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version, _impl_.zephyr_version_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version, _impl_.zmk_version_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version, _impl_.app_version_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::Version, _impl_.features_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.control_mode_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.current_angle_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.current_velocity_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.target_angle_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.target_velocity_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::MotorState, _impl_.target_voltage_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_.layer_id_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_.layer_name_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_.ppr_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig_Pref, _impl_.torque_limit_),
  1,
  0,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig, _impl_.demo_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::KnobConfig, _impl_.prefs_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbControl, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbControl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbControl, _impl_.command_),
  0,
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState_HSB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState_HSB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState_HSB, _impl_.h_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState_HSB, _impl_.s_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState_HSB, _impl_.b_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState, _impl_.on_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState, _impl_.effect_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbState, _impl_.speed_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbIndicator, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbIndicator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbIndicator, _impl_.enable_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbIndicator, _impl_.brightness_active_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::RgbIndicator, _impl_.brightness_inactive_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::usb::comm::EinkImage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::EinkImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::usb::comm::EinkImage, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::EinkImage, _impl_.bits_length_),
  PROTOBUF_FIELD_OFFSET(::usb::comm::EinkImage, _impl_.bits_),
  1,
  2,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 15, -1, sizeof(::usb::comm::MessageH2D)},
  { 23, 39, -1, sizeof(::usb::comm::MessageD2H)},
  { 48, -1, -1, sizeof(::usb::comm::Nop)},
  { 54, 66, -1, sizeof(::usb::comm::Version_Features)},
  { 72, 82, -1, sizeof(::usb::comm::Version)},
  { 86, 99, -1, sizeof(::usb::comm::MotorState)},
  { 106, 118, -1, sizeof(::usb::comm::KnobConfig_Pref)},
  { 124, 133, -1, sizeof(::usb::comm::KnobConfig)},
  { 136, 143, -1, sizeof(::usb::comm::RgbControl)},
  { 144, 153, -1, sizeof(::usb::comm::RgbState_HSB)},
  { 156, 166, -1, sizeof(::usb::comm::RgbState)},
  { 170, 179, -1, sizeof(::usb::comm::RgbIndicator)},
  { 182, 191, -1, sizeof(::usb::comm::EinkImage)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::usb::comm::_MessageH2D_default_instance_._instance,
  &::usb::comm::_MessageD2H_default_instance_._instance,
  &::usb::comm::_Nop_default_instance_._instance,
  &::usb::comm::_Version_Features_default_instance_._instance,
  &::usb::comm::_Version_default_instance_._instance,
  &::usb::comm::_MotorState_default_instance_._instance,
  &::usb::comm::_KnobConfig_Pref_default_instance_._instance,
  &::usb::comm::_KnobConfig_default_instance_._instance,
  &::usb::comm::_RgbControl_default_instance_._instance,
  &::usb::comm::_RgbState_HSB_default_instance_._instance,
  &::usb::comm::_RgbState_default_instance_._instance,
  &::usb::comm::_RgbIndicator_default_instance_._instance,
  &::usb::comm::_EinkImage_default_instance_._instance,
};

const char descriptor_table_protodef_usb_5fcomm_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016usb_comm.proto\022\010usb.comm\"\346\002\n\nMessageH2"
  "D\022 \n\006action\030\001 \002(\0162\020.usb.comm.Action\022\034\n\003n"
  "op\030\002 \001(\0132\r.usb.comm.NopH\000\022+\n\013knob_config"
  "\030\003 \001(\0132\024.usb.comm.KnobConfigH\000\022.\n\tknob_p"
  "ref\030\006 \001(\0132\031.usb.comm.KnobConfig.PrefH\000\022+"
  "\n\013rgb_control\030\004 \001(\0132\024.usb.comm.RgbContro"
  "lH\000\022\'\n\trgb_state\030\007 \001(\0132\022.usb.comm.RgbSta"
  "teH\000\022/\n\rrgb_indicator\030\010 \001(\0132\026.usb.comm.R"
  "gbIndicatorH\000\022)\n\neink_image\030\005 \001(\0132\023.usb."
  "comm.EinkImageH\000B\t\n\007payload\"\214\003\n\nMessageD"
  "2H\022 \n\006action\030\001 \002(\0162\020.usb.comm.Action\022\034\n\003"
  "nop\030\002 \001(\0132\r.usb.comm.NopH\000\022$\n\007version\030\003 "
  "\001(\0132\021.usb.comm.VersionH\000\022+\n\013motor_state\030"
  "\004 \001(\0132\024.usb.comm.MotorStateH\000\022+\n\013knob_co"
  "nfig\030\005 \001(\0132\024.usb.comm.KnobConfigH\000\022.\n\tkn"
  "ob_pref\030\010 \001(\0132\031.usb.comm.KnobConfig.Pref"
  "H\000\022\'\n\trgb_state\030\006 \001(\0132\022.usb.comm.RgbStat"
  "eH\000\022/\n\rrgb_indicator\030\t \001(\0132\026.usb.comm.Rg"
  "bIndicatorH\000\022)\n\neink_image\030\007 \001(\0132\023.usb.c"
  "omm.EinkImageH\000B\t\n\007payload\"\005\n\003Nop\"\363\001\n\007Ve"
  "rsion\022\026\n\016zephyr_version\030\001 \002(\t\022\023\n\013zmk_ver"
  "sion\030\002 \002(\t\022\023\n\013app_version\030\003 \002(\t\022,\n\010featu"
  "res\030\004 \001(\0132\032.usb.comm.Version.Features\032x\n"
  "\010Features\022\013\n\003rgb\030\001 \001(\010\022\030\n\020rgb_full_contr"
  "ol\030\005 \001(\010\022\025\n\rrgb_indicator\030\006 \001(\010\022\014\n\004eink\030"
  "\002 \001(\010\022\014\n\004knob\030\003 \001(\010\022\022\n\nknob_prefs\030\004 \001(\010\""
  "\203\002\n\nMotorState\022\021\n\ttimestamp\030\001 \002(\r\0226\n\014con"
  "trol_mode\030\002 \002(\0162 .usb.comm.MotorState.Co"
  "ntrolMode\022\025\n\rcurrent_angle\030\003 \002(\002\022\030\n\020curr"
  "ent_velocity\030\004 \002(\002\022\024\n\014target_angle\030\005 \002(\002"
  "\022\027\n\017target_velocity\030\006 \002(\002\022\026\n\016target_volt"
  "age\030\007 \002(\002\"2\n\013ControlMode\022\n\n\006TORQUE\020\000\022\014\n\010"
  "VELOCITY\020\001\022\t\n\005ANGLE\020\002\"\326\002\n\nKnobConfig\022\014\n\004"
  "demo\030\001 \002(\010\022\'\n\004mode\030\002 \002(\0162\031.usb.comm.Knob"
  "Config.Mode\022(\n\005prefs\030\005 \003(\0132\031.usb.comm.Kn"
  "obConfig.Pref\032\210\001\n\004Pref\022\020\n\010layer_id\030\001 \002(\r"
  "\022\022\n\nlayer_name\030\002 \001(\t\022\016\n\006active\030\003 \002(\010\022\'\n\004"
  "mode\030\004 \001(\0162\031.usb.comm.KnobConfig.Mode\022\013\n"
  "\003ppr\030\005 \001(\r\022\024\n\014torque_limit\030\006 \001(\002\"\\\n\004Mode"
  "\022\013\n\007DISABLE\020\000\022\013\n\007INERTIA\020\001\022\013\n\007ENCODER\020\002\022"
  "\n\n\006SPRING\020\003\022\n\n\006DAMPED\020\004\022\010\n\004SPIN\020\005\022\013\n\007RAT"
  "CHET\020\006\"\342\001\n\nRgbControl\022-\n\007command\030\001 \002(\0162\034"
  ".usb.comm.RgbControl.Command\"\244\001\n\007Command"
  "\022\n\n\006RGB_ON\020\001\022\013\n\007RGB_OFF\020\002\022\013\n\007RGB_HUI\020\003\022\013"
  "\n\007RGB_HUD\020\004\022\013\n\007RGB_SAI\020\005\022\013\n\007RGB_SAD\020\006\022\013\n"
  "\007RGB_BRI\020\007\022\013\n\007RGB_BRD\020\010\022\013\n\007RGB_SPI\020\t\022\013\n\007"
  "RGB_SPD\020\n\022\013\n\007RGB_EFF\020\013\022\013\n\007RGB_EFR\020\014\"\332\001\n\010"
  "RgbState\022\n\n\002on\030\001 \002(\010\022%\n\005color\030\002 \001(\0132\026.us"
  "b.comm.RgbState.HSB\022)\n\006effect\030\003 \001(\0162\031.us"
  "b.comm.RgbState.Effect\022\r\n\005speed\030\004 \001(\r\032&\n"
  "\003HSB\022\t\n\001h\030\001 \002(\r\022\t\n\001s\030\002 \002(\r\022\t\n\001b\030\003 \002(\r\"9\n"
  "\006Effect\022\t\n\005SOLID\020\000\022\013\n\007BREATHE\020\001\022\014\n\010SPECT"
  "RUM\020\002\022\t\n\005SWIRL\020\003\"V\n\014RgbIndicator\022\016\n\006enab"
  "le\030\001 \001(\010\022\031\n\021brightness_active\030\002 \001(\r\022\033\n\023b"
  "rightness_inactive\030\003 \001(\r\">\n\tEinkImage\022\n\n"
  "\002id\030\001 \002(\r\022\027\n\013bits_length\030\002 \001(\rB\002\030\001\022\014\n\004bi"
  "ts\030\003 \001(\014*\354\001\n\006Action\022\007\n\003NOP\020\000\022\013\n\007VERSION\020"
  "\001\022\023\n\017MOTOR_GET_STATE\020\002\022\023\n\017KNOB_GET_CONFI"
  "G\020\003\022\023\n\017KNOB_SET_CONFIG\020\004\022\024\n\020KNOB_UPDATE_"
  "PREF\020\t\022\017\n\013RGB_CONTROL\020\005\022\021\n\rRGB_GET_STATE"
  "\020\006\022\021\n\rRGB_SET_STATE\020\010\022\025\n\021RGB_GET_INDICAT"
  "OR\020\n\022\025\n\021RGB_SET_INDICATOR\020\013\022\022\n\016EINK_SET_"
  "IMAGE\020\007"
  ;
static ::_pbi::once_flag descriptor_table_usb_5fcomm_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_usb_5fcomm_2eproto = {
    false, false, 2487, descriptor_table_protodef_usb_5fcomm_2eproto,
    "usb_comm.proto",
    &descriptor_table_usb_5fcomm_2eproto_once, nullptr, 0, 13,
    schemas, file_default_instances, TableStruct_usb_5fcomm_2eproto::offsets,
    file_level_metadata_usb_5fcomm_2eproto, file_level_enum_descriptors_usb_5fcomm_2eproto,
    file_level_service_descriptors_usb_5fcomm_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_usb_5fcomm_2eproto_getter() {
  return &descriptor_table_usb_5fcomm_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_usb_5fcomm_2eproto(&descriptor_table_usb_5fcomm_2eproto);
namespace usb {
namespace comm {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotorState_ControlMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_usb_5fcomm_2eproto);
  return file_level_enum_descriptors_usb_5fcomm_2eproto[0];
}
bool MotorState_ControlMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MotorState_ControlMode MotorState::TORQUE;
constexpr MotorState_ControlMode MotorState::VELOCITY;
constexpr MotorState_ControlMode MotorState::ANGLE;
constexpr MotorState_ControlMode MotorState::ControlMode_MIN;
constexpr MotorState_ControlMode MotorState::ControlMode_MAX;
constexpr int MotorState::ControlMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnobConfig_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_usb_5fcomm_2eproto);
  return file_level_enum_descriptors_usb_5fcomm_2eproto[1];
}
bool KnobConfig_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr KnobConfig_Mode KnobConfig::DISABLE;
constexpr KnobConfig_Mode KnobConfig::INERTIA;
constexpr KnobConfig_Mode KnobConfig::ENCODER;
constexpr KnobConfig_Mode KnobConfig::SPRING;
constexpr KnobConfig_Mode KnobConfig::DAMPED;
constexpr KnobConfig_Mode KnobConfig::SPIN;
constexpr KnobConfig_Mode KnobConfig::RATCHET;
constexpr KnobConfig_Mode KnobConfig::Mode_MIN;
constexpr KnobConfig_Mode KnobConfig::Mode_MAX;
constexpr int KnobConfig::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RgbControl_Command_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_usb_5fcomm_2eproto);
  return file_level_enum_descriptors_usb_5fcomm_2eproto[2];
}
bool RgbControl_Command_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RgbControl_Command RgbControl::RGB_ON;
constexpr RgbControl_Command RgbControl::RGB_OFF;
constexpr RgbControl_Command RgbControl::RGB_HUI;
constexpr RgbControl_Command RgbControl::RGB_HUD;
constexpr RgbControl_Command RgbControl::RGB_SAI;
constexpr RgbControl_Command RgbControl::RGB_SAD;
constexpr RgbControl_Command RgbControl::RGB_BRI;
constexpr RgbControl_Command RgbControl::RGB_BRD;
constexpr RgbControl_Command RgbControl::RGB_SPI;
constexpr RgbControl_Command RgbControl::RGB_SPD;
constexpr RgbControl_Command RgbControl::RGB_EFF;
constexpr RgbControl_Command RgbControl::RGB_EFR;
constexpr RgbControl_Command RgbControl::Command_MIN;
constexpr RgbControl_Command RgbControl::Command_MAX;
constexpr int RgbControl::Command_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RgbState_Effect_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_usb_5fcomm_2eproto);
  return file_level_enum_descriptors_usb_5fcomm_2eproto[3];
}
bool RgbState_Effect_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RgbState_Effect RgbState::SOLID;
constexpr RgbState_Effect RgbState::BREATHE;
constexpr RgbState_Effect RgbState::SPECTRUM;
constexpr RgbState_Effect RgbState::SWIRL;
constexpr RgbState_Effect RgbState::Effect_MIN;
constexpr RgbState_Effect RgbState::Effect_MAX;
constexpr int RgbState::Effect_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_usb_5fcomm_2eproto);
  return file_level_enum_descriptors_usb_5fcomm_2eproto[4];
}
bool Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class MessageH2D::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageH2D>()._impl_._has_bits_);
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::usb::comm::Nop& nop(const MessageH2D* msg);
  static const ::usb::comm::KnobConfig& knob_config(const MessageH2D* msg);
  static const ::usb::comm::KnobConfig_Pref& knob_pref(const MessageH2D* msg);
  static const ::usb::comm::RgbControl& rgb_control(const MessageH2D* msg);
  static const ::usb::comm::RgbState& rgb_state(const MessageH2D* msg);
  static const ::usb::comm::RgbIndicator& rgb_indicator(const MessageH2D* msg);
  static const ::usb::comm::EinkImage& eink_image(const MessageH2D* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::usb::comm::Nop&
MessageH2D::_Internal::nop(const MessageH2D* msg) {
  return *msg->_impl_.payload_.nop_;
}
const ::usb::comm::KnobConfig&
MessageH2D::_Internal::knob_config(const MessageH2D* msg) {
  return *msg->_impl_.payload_.knob_config_;
}
const ::usb::comm::KnobConfig_Pref&
MessageH2D::_Internal::knob_pref(const MessageH2D* msg) {
  return *msg->_impl_.payload_.knob_pref_;
}
const ::usb::comm::RgbControl&
MessageH2D::_Internal::rgb_control(const MessageH2D* msg) {
  return *msg->_impl_.payload_.rgb_control_;
}
const ::usb::comm::RgbState&
MessageH2D::_Internal::rgb_state(const MessageH2D* msg) {
  return *msg->_impl_.payload_.rgb_state_;
}
const ::usb::comm::RgbIndicator&
MessageH2D::_Internal::rgb_indicator(const MessageH2D* msg) {
  return *msg->_impl_.payload_.rgb_indicator_;
}
const ::usb::comm::EinkImage&
MessageH2D::_Internal::eink_image(const MessageH2D* msg) {
  return *msg->_impl_.payload_.eink_image_;
}
void MessageH2D::set_allocated_nop(::usb::comm::Nop* nop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (nop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nop);
    if (message_arena != submessage_arena) {
      nop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nop, submessage_arena);
    }
    set_has_nop();
    _impl_.payload_.nop_ = nop;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.nop)
}
void MessageH2D::set_allocated_knob_config(::usb::comm::KnobConfig* knob_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (knob_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(knob_config);
    if (message_arena != submessage_arena) {
      knob_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, knob_config, submessage_arena);
    }
    set_has_knob_config();
    _impl_.payload_.knob_config_ = knob_config;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.knob_config)
}
void MessageH2D::set_allocated_knob_pref(::usb::comm::KnobConfig_Pref* knob_pref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (knob_pref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(knob_pref);
    if (message_arena != submessage_arena) {
      knob_pref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, knob_pref, submessage_arena);
    }
    set_has_knob_pref();
    _impl_.payload_.knob_pref_ = knob_pref;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.knob_pref)
}
void MessageH2D::set_allocated_rgb_control(::usb::comm::RgbControl* rgb_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (rgb_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rgb_control);
    if (message_arena != submessage_arena) {
      rgb_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rgb_control, submessage_arena);
    }
    set_has_rgb_control();
    _impl_.payload_.rgb_control_ = rgb_control;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.rgb_control)
}
void MessageH2D::set_allocated_rgb_state(::usb::comm::RgbState* rgb_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (rgb_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rgb_state);
    if (message_arena != submessage_arena) {
      rgb_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rgb_state, submessage_arena);
    }
    set_has_rgb_state();
    _impl_.payload_.rgb_state_ = rgb_state;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.rgb_state)
}
void MessageH2D::set_allocated_rgb_indicator(::usb::comm::RgbIndicator* rgb_indicator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (rgb_indicator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rgb_indicator);
    if (message_arena != submessage_arena) {
      rgb_indicator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rgb_indicator, submessage_arena);
    }
    set_has_rgb_indicator();
    _impl_.payload_.rgb_indicator_ = rgb_indicator;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.rgb_indicator)
}
void MessageH2D::set_allocated_eink_image(::usb::comm::EinkImage* eink_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (eink_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eink_image);
    if (message_arena != submessage_arena) {
      eink_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eink_image, submessage_arena);
    }
    set_has_eink_image();
    _impl_.payload_.eink_image_ = eink_image;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageH2D.eink_image)
}
MessageH2D::MessageH2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.MessageH2D)
}
MessageH2D::MessageH2D(const MessageH2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageH2D* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_){}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.action_ = from._impl_.action_;
  clear_has_payload();
  switch (from.payload_case()) {
    case kNop: {
      _this->_internal_mutable_nop()->::usb::comm::Nop::MergeFrom(
          from._internal_nop());
      break;
    }
    case kKnobConfig: {
      _this->_internal_mutable_knob_config()->::usb::comm::KnobConfig::MergeFrom(
          from._internal_knob_config());
      break;
    }
    case kKnobPref: {
      _this->_internal_mutable_knob_pref()->::usb::comm::KnobConfig_Pref::MergeFrom(
          from._internal_knob_pref());
      break;
    }
    case kRgbControl: {
      _this->_internal_mutable_rgb_control()->::usb::comm::RgbControl::MergeFrom(
          from._internal_rgb_control());
      break;
    }
    case kRgbState: {
      _this->_internal_mutable_rgb_state()->::usb::comm::RgbState::MergeFrom(
          from._internal_rgb_state());
      break;
    }
    case kRgbIndicator: {
      _this->_internal_mutable_rgb_indicator()->::usb::comm::RgbIndicator::MergeFrom(
          from._internal_rgb_indicator());
      break;
    }
    case kEinkImage: {
      _this->_internal_mutable_eink_image()->::usb::comm::EinkImage::MergeFrom(
          from._internal_eink_image());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:usb.comm.MessageH2D)
}

inline void MessageH2D::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_){0}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

MessageH2D::~MessageH2D() {
  // @@protoc_insertion_point(destructor:usb.comm.MessageH2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageH2D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void MessageH2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageH2D::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:usb.comm.MessageH2D)
  switch (payload_case()) {
    case kNop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.nop_;
      }
      break;
    }
    case kKnobConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.knob_config_;
      }
      break;
    }
    case kKnobPref: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.knob_pref_;
      }
      break;
    }
    case kRgbControl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.rgb_control_;
      }
      break;
    }
    case kRgbState: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.rgb_state_;
      }
      break;
    }
    case kRgbIndicator: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.rgb_indicator_;
      }
      break;
    }
    case kEinkImage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.eink_image_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void MessageH2D::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.MessageH2D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.action_ = 0;
  clear_payload();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageH2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .usb.comm.Action action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::Action_IsValid(val))) {
            _internal_set_action(static_cast<::usb::comm::Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.Nop nop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.KnobConfig knob_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_knob_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.RgbControl rgb_control = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgb_control(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.EinkImage eink_image = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_eink_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.KnobConfig.Pref knob_pref = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_knob_pref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.RgbState rgb_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgb_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.RgbIndicator rgb_indicator = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgb_indicator(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageH2D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.MessageH2D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .usb.comm.Action action = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action(), target);
  }

  switch (payload_case()) {
    case kNop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::nop(this),
          _Internal::nop(this).GetCachedSize(), target, stream);
      break;
    }
    case kKnobConfig: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::knob_config(this),
          _Internal::knob_config(this).GetCachedSize(), target, stream);
      break;
    }
    case kRgbControl: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::rgb_control(this),
          _Internal::rgb_control(this).GetCachedSize(), target, stream);
      break;
    }
    case kEinkImage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::eink_image(this),
          _Internal::eink_image(this).GetCachedSize(), target, stream);
      break;
    }
    case kKnobPref: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::knob_pref(this),
          _Internal::knob_pref(this).GetCachedSize(), target, stream);
      break;
    }
    case kRgbState: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::rgb_state(this),
          _Internal::rgb_state(this).GetCachedSize(), target, stream);
      break;
    }
    case kRgbIndicator: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::rgb_indicator(this),
          _Internal::rgb_indicator(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.MessageH2D)
  return target;
}

size_t MessageH2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.MessageH2D)
  size_t total_size = 0;

  // required .usb.comm.Action action = 1;
  if (_internal_has_action()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .usb.comm.Nop nop = 2;
    case kNop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.nop_);
      break;
    }
    // .usb.comm.KnobConfig knob_config = 3;
    case kKnobConfig: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.knob_config_);
      break;
    }
    // .usb.comm.KnobConfig.Pref knob_pref = 6;
    case kKnobPref: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.knob_pref_);
      break;
    }
    // .usb.comm.RgbControl rgb_control = 4;
    case kRgbControl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.rgb_control_);
      break;
    }
    // .usb.comm.RgbState rgb_state = 7;
    case kRgbState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.rgb_state_);
      break;
    }
    // .usb.comm.RgbIndicator rgb_indicator = 8;
    case kRgbIndicator: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.rgb_indicator_);
      break;
    }
    // .usb.comm.EinkImage eink_image = 5;
    case kEinkImage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.eink_image_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageH2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageH2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageH2D::GetClassData() const { return &_class_data_; }


void MessageH2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageH2D*>(&to_msg);
  auto& from = static_cast<const MessageH2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.MessageH2D)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_action()) {
    _this->_internal_set_action(from._internal_action());
  }
  switch (from.payload_case()) {
    case kNop: {
      _this->_internal_mutable_nop()->::usb::comm::Nop::MergeFrom(
          from._internal_nop());
      break;
    }
    case kKnobConfig: {
      _this->_internal_mutable_knob_config()->::usb::comm::KnobConfig::MergeFrom(
          from._internal_knob_config());
      break;
    }
    case kKnobPref: {
      _this->_internal_mutable_knob_pref()->::usb::comm::KnobConfig_Pref::MergeFrom(
          from._internal_knob_pref());
      break;
    }
    case kRgbControl: {
      _this->_internal_mutable_rgb_control()->::usb::comm::RgbControl::MergeFrom(
          from._internal_rgb_control());
      break;
    }
    case kRgbState: {
      _this->_internal_mutable_rgb_state()->::usb::comm::RgbState::MergeFrom(
          from._internal_rgb_state());
      break;
    }
    case kRgbIndicator: {
      _this->_internal_mutable_rgb_indicator()->::usb::comm::RgbIndicator::MergeFrom(
          from._internal_rgb_indicator());
      break;
    }
    case kEinkImage: {
      _this->_internal_mutable_eink_image()->::usb::comm::EinkImage::MergeFrom(
          from._internal_eink_image());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageH2D::CopyFrom(const MessageH2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.MessageH2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageH2D::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (payload_case()) {
    case kNop: {
      break;
    }
    case kKnobConfig: {
      if (_internal_has_knob_config()) {
        if (!_impl_.payload_.knob_config_->IsInitialized()) return false;
      }
      break;
    }
    case kKnobPref: {
      if (_internal_has_knob_pref()) {
        if (!_impl_.payload_.knob_pref_->IsInitialized()) return false;
      }
      break;
    }
    case kRgbControl: {
      if (_internal_has_rgb_control()) {
        if (!_impl_.payload_.rgb_control_->IsInitialized()) return false;
      }
      break;
    }
    case kRgbState: {
      if (_internal_has_rgb_state()) {
        if (!_impl_.payload_.rgb_state_->IsInitialized()) return false;
      }
      break;
    }
    case kRgbIndicator: {
      break;
    }
    case kEinkImage: {
      if (_internal_has_eink_image()) {
        if (!_impl_.payload_.eink_image_->IsInitialized()) return false;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void MessageH2D::InternalSwap(MessageH2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageH2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[0]);
}

// ===================================================================

class MessageD2H::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageD2H>()._impl_._has_bits_);
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::usb::comm::Nop& nop(const MessageD2H* msg);
  static const ::usb::comm::Version& version(const MessageD2H* msg);
  static const ::usb::comm::MotorState& motor_state(const MessageD2H* msg);
  static const ::usb::comm::KnobConfig& knob_config(const MessageD2H* msg);
  static const ::usb::comm::KnobConfig_Pref& knob_pref(const MessageD2H* msg);
  static const ::usb::comm::RgbState& rgb_state(const MessageD2H* msg);
  static const ::usb::comm::RgbIndicator& rgb_indicator(const MessageD2H* msg);
  static const ::usb::comm::EinkImage& eink_image(const MessageD2H* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::usb::comm::Nop&
MessageD2H::_Internal::nop(const MessageD2H* msg) {
  return *msg->_impl_.payload_.nop_;
}
const ::usb::comm::Version&
MessageD2H::_Internal::version(const MessageD2H* msg) {
  return *msg->_impl_.payload_.version_;
}
const ::usb::comm::MotorState&
MessageD2H::_Internal::motor_state(const MessageD2H* msg) {
  return *msg->_impl_.payload_.motor_state_;
}
const ::usb::comm::KnobConfig&
MessageD2H::_Internal::knob_config(const MessageD2H* msg) {
  return *msg->_impl_.payload_.knob_config_;
}
const ::usb::comm::KnobConfig_Pref&
MessageD2H::_Internal::knob_pref(const MessageD2H* msg) {
  return *msg->_impl_.payload_.knob_pref_;
}
const ::usb::comm::RgbState&
MessageD2H::_Internal::rgb_state(const MessageD2H* msg) {
  return *msg->_impl_.payload_.rgb_state_;
}
const ::usb::comm::RgbIndicator&
MessageD2H::_Internal::rgb_indicator(const MessageD2H* msg) {
  return *msg->_impl_.payload_.rgb_indicator_;
}
const ::usb::comm::EinkImage&
MessageD2H::_Internal::eink_image(const MessageD2H* msg) {
  return *msg->_impl_.payload_.eink_image_;
}
void MessageD2H::set_allocated_nop(::usb::comm::Nop* nop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (nop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nop);
    if (message_arena != submessage_arena) {
      nop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nop, submessage_arena);
    }
    set_has_nop();
    _impl_.payload_.nop_ = nop;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.nop)
}
void MessageD2H::set_allocated_version(::usb::comm::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    set_has_version();
    _impl_.payload_.version_ = version;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.version)
}
void MessageD2H::set_allocated_motor_state(::usb::comm::MotorState* motor_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (motor_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motor_state);
    if (message_arena != submessage_arena) {
      motor_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motor_state, submessage_arena);
    }
    set_has_motor_state();
    _impl_.payload_.motor_state_ = motor_state;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.motor_state)
}
void MessageD2H::set_allocated_knob_config(::usb::comm::KnobConfig* knob_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (knob_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(knob_config);
    if (message_arena != submessage_arena) {
      knob_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, knob_config, submessage_arena);
    }
    set_has_knob_config();
    _impl_.payload_.knob_config_ = knob_config;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.knob_config)
}
void MessageD2H::set_allocated_knob_pref(::usb::comm::KnobConfig_Pref* knob_pref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (knob_pref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(knob_pref);
    if (message_arena != submessage_arena) {
      knob_pref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, knob_pref, submessage_arena);
    }
    set_has_knob_pref();
    _impl_.payload_.knob_pref_ = knob_pref;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.knob_pref)
}
void MessageD2H::set_allocated_rgb_state(::usb::comm::RgbState* rgb_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (rgb_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rgb_state);
    if (message_arena != submessage_arena) {
      rgb_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rgb_state, submessage_arena);
    }
    set_has_rgb_state();
    _impl_.payload_.rgb_state_ = rgb_state;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.rgb_state)
}
void MessageD2H::set_allocated_rgb_indicator(::usb::comm::RgbIndicator* rgb_indicator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (rgb_indicator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rgb_indicator);
    if (message_arena != submessage_arena) {
      rgb_indicator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rgb_indicator, submessage_arena);
    }
    set_has_rgb_indicator();
    _impl_.payload_.rgb_indicator_ = rgb_indicator;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.rgb_indicator)
}
void MessageD2H::set_allocated_eink_image(::usb::comm::EinkImage* eink_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (eink_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eink_image);
    if (message_arena != submessage_arena) {
      eink_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eink_image, submessage_arena);
    }
    set_has_eink_image();
    _impl_.payload_.eink_image_ = eink_image;
  }
  // @@protoc_insertion_point(field_set_allocated:usb.comm.MessageD2H.eink_image)
}
MessageD2H::MessageD2H(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.MessageD2H)
}
MessageD2H::MessageD2H(const MessageD2H& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageD2H* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_){}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.action_ = from._impl_.action_;
  clear_has_payload();
  switch (from.payload_case()) {
    case kNop: {
      _this->_internal_mutable_nop()->::usb::comm::Nop::MergeFrom(
          from._internal_nop());
      break;
    }
    case kVersion: {
      _this->_internal_mutable_version()->::usb::comm::Version::MergeFrom(
          from._internal_version());
      break;
    }
    case kMotorState: {
      _this->_internal_mutable_motor_state()->::usb::comm::MotorState::MergeFrom(
          from._internal_motor_state());
      break;
    }
    case kKnobConfig: {
      _this->_internal_mutable_knob_config()->::usb::comm::KnobConfig::MergeFrom(
          from._internal_knob_config());
      break;
    }
    case kKnobPref: {
      _this->_internal_mutable_knob_pref()->::usb::comm::KnobConfig_Pref::MergeFrom(
          from._internal_knob_pref());
      break;
    }
    case kRgbState: {
      _this->_internal_mutable_rgb_state()->::usb::comm::RgbState::MergeFrom(
          from._internal_rgb_state());
      break;
    }
    case kRgbIndicator: {
      _this->_internal_mutable_rgb_indicator()->::usb::comm::RgbIndicator::MergeFrom(
          from._internal_rgb_indicator());
      break;
    }
    case kEinkImage: {
      _this->_internal_mutable_eink_image()->::usb::comm::EinkImage::MergeFrom(
          from._internal_eink_image());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:usb.comm.MessageD2H)
}

inline void MessageD2H::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_){0}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

MessageD2H::~MessageD2H() {
  // @@protoc_insertion_point(destructor:usb.comm.MessageD2H)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageD2H::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void MessageD2H::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageD2H::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:usb.comm.MessageD2H)
  switch (payload_case()) {
    case kNop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.nop_;
      }
      break;
    }
    case kVersion: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.version_;
      }
      break;
    }
    case kMotorState: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.motor_state_;
      }
      break;
    }
    case kKnobConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.knob_config_;
      }
      break;
    }
    case kKnobPref: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.knob_pref_;
      }
      break;
    }
    case kRgbState: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.rgb_state_;
      }
      break;
    }
    case kRgbIndicator: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.rgb_indicator_;
      }
      break;
    }
    case kEinkImage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.eink_image_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void MessageD2H::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.MessageD2H)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.action_ = 0;
  clear_payload();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageD2H::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .usb.comm.Action action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::Action_IsValid(val))) {
            _internal_set_action(static_cast<::usb::comm::Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.Nop nop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.Version version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.MotorState motor_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.KnobConfig knob_config = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_knob_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.RgbState rgb_state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgb_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.EinkImage eink_image = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_eink_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.KnobConfig.Pref knob_pref = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_knob_pref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .usb.comm.RgbIndicator rgb_indicator = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgb_indicator(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageD2H::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.MessageD2H)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .usb.comm.Action action = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action(), target);
  }

  switch (payload_case()) {
    case kNop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::nop(this),
          _Internal::nop(this).GetCachedSize(), target, stream);
      break;
    }
    case kVersion: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::version(this),
          _Internal::version(this).GetCachedSize(), target, stream);
      break;
    }
    case kMotorState: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::motor_state(this),
          _Internal::motor_state(this).GetCachedSize(), target, stream);
      break;
    }
    case kKnobConfig: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::knob_config(this),
          _Internal::knob_config(this).GetCachedSize(), target, stream);
      break;
    }
    case kRgbState: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::rgb_state(this),
          _Internal::rgb_state(this).GetCachedSize(), target, stream);
      break;
    }
    case kEinkImage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::eink_image(this),
          _Internal::eink_image(this).GetCachedSize(), target, stream);
      break;
    }
    case kKnobPref: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::knob_pref(this),
          _Internal::knob_pref(this).GetCachedSize(), target, stream);
      break;
    }
    case kRgbIndicator: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::rgb_indicator(this),
          _Internal::rgb_indicator(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.MessageD2H)
  return target;
}

size_t MessageD2H::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.MessageD2H)
  size_t total_size = 0;

  // required .usb.comm.Action action = 1;
  if (_internal_has_action()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .usb.comm.Nop nop = 2;
    case kNop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.nop_);
      break;
    }
    // .usb.comm.Version version = 3;
    case kVersion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.version_);
      break;
    }
    // .usb.comm.MotorState motor_state = 4;
    case kMotorState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.motor_state_);
      break;
    }
    // .usb.comm.KnobConfig knob_config = 5;
    case kKnobConfig: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.knob_config_);
      break;
    }
    // .usb.comm.KnobConfig.Pref knob_pref = 8;
    case kKnobPref: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.knob_pref_);
      break;
    }
    // .usb.comm.RgbState rgb_state = 6;
    case kRgbState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.rgb_state_);
      break;
    }
    // .usb.comm.RgbIndicator rgb_indicator = 9;
    case kRgbIndicator: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.rgb_indicator_);
      break;
    }
    // .usb.comm.EinkImage eink_image = 7;
    case kEinkImage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.eink_image_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageD2H::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageD2H::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageD2H::GetClassData() const { return &_class_data_; }


void MessageD2H::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageD2H*>(&to_msg);
  auto& from = static_cast<const MessageD2H&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.MessageD2H)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_action()) {
    _this->_internal_set_action(from._internal_action());
  }
  switch (from.payload_case()) {
    case kNop: {
      _this->_internal_mutable_nop()->::usb::comm::Nop::MergeFrom(
          from._internal_nop());
      break;
    }
    case kVersion: {
      _this->_internal_mutable_version()->::usb::comm::Version::MergeFrom(
          from._internal_version());
      break;
    }
    case kMotorState: {
      _this->_internal_mutable_motor_state()->::usb::comm::MotorState::MergeFrom(
          from._internal_motor_state());
      break;
    }
    case kKnobConfig: {
      _this->_internal_mutable_knob_config()->::usb::comm::KnobConfig::MergeFrom(
          from._internal_knob_config());
      break;
    }
    case kKnobPref: {
      _this->_internal_mutable_knob_pref()->::usb::comm::KnobConfig_Pref::MergeFrom(
          from._internal_knob_pref());
      break;
    }
    case kRgbState: {
      _this->_internal_mutable_rgb_state()->::usb::comm::RgbState::MergeFrom(
          from._internal_rgb_state());
      break;
    }
    case kRgbIndicator: {
      _this->_internal_mutable_rgb_indicator()->::usb::comm::RgbIndicator::MergeFrom(
          from._internal_rgb_indicator());
      break;
    }
    case kEinkImage: {
      _this->_internal_mutable_eink_image()->::usb::comm::EinkImage::MergeFrom(
          from._internal_eink_image());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageD2H::CopyFrom(const MessageD2H& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.MessageD2H)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageD2H::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (payload_case()) {
    case kNop: {
      break;
    }
    case kVersion: {
      if (_internal_has_version()) {
        if (!_impl_.payload_.version_->IsInitialized()) return false;
      }
      break;
    }
    case kMotorState: {
      if (_internal_has_motor_state()) {
        if (!_impl_.payload_.motor_state_->IsInitialized()) return false;
      }
      break;
    }
    case kKnobConfig: {
      if (_internal_has_knob_config()) {
        if (!_impl_.payload_.knob_config_->IsInitialized()) return false;
      }
      break;
    }
    case kKnobPref: {
      if (_internal_has_knob_pref()) {
        if (!_impl_.payload_.knob_pref_->IsInitialized()) return false;
      }
      break;
    }
    case kRgbState: {
      if (_internal_has_rgb_state()) {
        if (!_impl_.payload_.rgb_state_->IsInitialized()) return false;
      }
      break;
    }
    case kRgbIndicator: {
      break;
    }
    case kEinkImage: {
      if (_internal_has_eink_image()) {
        if (!_impl_.payload_.eink_image_->IsInitialized()) return false;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void MessageD2H::InternalSwap(MessageD2H* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageD2H::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[1]);
}

// ===================================================================

class Nop::_Internal {
 public:
};

Nop::Nop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:usb.comm.Nop)
}
Nop::Nop(const Nop& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Nop* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:usb.comm.Nop)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Nop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Nop::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Nop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[2]);
}

// ===================================================================

class Version_Features::_Internal {
 public:
  using HasBits = decltype(std::declval<Version_Features>()._impl_._has_bits_);
  static void set_has_rgb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rgb_full_control(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rgb_indicator(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_eink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_knob(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_knob_prefs(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Version_Features::Version_Features(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.Version.Features)
}
Version_Features::Version_Features(const Version_Features& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Version_Features* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rgb_){}
    , decltype(_impl_.rgb_full_control_){}
    , decltype(_impl_.rgb_indicator_){}
    , decltype(_impl_.eink_){}
    , decltype(_impl_.knob_){}
    , decltype(_impl_.knob_prefs_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.rgb_, &from._impl_.rgb_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.knob_prefs_) -
    reinterpret_cast<char*>(&_impl_.rgb_)) + sizeof(_impl_.knob_prefs_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.Version.Features)
}

inline void Version_Features::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rgb_){false}
    , decltype(_impl_.rgb_full_control_){false}
    , decltype(_impl_.rgb_indicator_){false}
    , decltype(_impl_.eink_){false}
    , decltype(_impl_.knob_){false}
    , decltype(_impl_.knob_prefs_){false}
  };
}

Version_Features::~Version_Features() {
  // @@protoc_insertion_point(destructor:usb.comm.Version.Features)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version_Features::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Version_Features::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Version_Features::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.Version.Features)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.rgb_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.knob_prefs_) -
        reinterpret_cast<char*>(&_impl_.rgb_)) + sizeof(_impl_.knob_prefs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Version_Features::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool rgb = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rgb(&has_bits);
          _impl_.rgb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool eink = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_eink(&has_bits);
          _impl_.eink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool knob = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_knob(&has_bits);
          _impl_.knob_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool knob_prefs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_knob_prefs(&has_bits);
          _impl_.knob_prefs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool rgb_full_control = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rgb_full_control(&has_bits);
          _impl_.rgb_full_control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool rgb_indicator = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_rgb_indicator(&has_bits);
          _impl_.rgb_indicator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version_Features::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.Version.Features)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool rgb = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_rgb(), target);
  }

  // optional bool eink = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_eink(), target);
  }

  // optional bool knob = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_knob(), target);
  }

  // optional bool knob_prefs = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_knob_prefs(), target);
  }

  // optional bool rgb_full_control = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_rgb_full_control(), target);
  }

  // optional bool rgb_indicator = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_rgb_indicator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.Version.Features)
  return target;
}

size_t Version_Features::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.Version.Features)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bool rgb = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool rgb_full_control = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool rgb_indicator = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool eink = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool knob = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool knob_prefs = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Version_Features::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Version_Features::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Version_Features::GetClassData() const { return &_class_data_; }


void Version_Features::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Version_Features*>(&to_msg);
  auto& from = static_cast<const Version_Features&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.Version.Features)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rgb_ = from._impl_.rgb_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rgb_full_control_ = from._impl_.rgb_full_control_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rgb_indicator_ = from._impl_.rgb_indicator_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.eink_ = from._impl_.eink_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.knob_ = from._impl_.knob_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.knob_prefs_ = from._impl_.knob_prefs_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Version_Features::CopyFrom(const Version_Features& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.Version.Features)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version_Features::IsInitialized() const {
  return true;
}

void Version_Features::InternalSwap(Version_Features* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Version_Features, _impl_.knob_prefs_)
      + sizeof(Version_Features::_impl_.knob_prefs_)
      - PROTOBUF_FIELD_OFFSET(Version_Features, _impl_.rgb_)>(
          reinterpret_cast<char*>(&_impl_.rgb_),
          reinterpret_cast<char*>(&other->_impl_.rgb_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Version_Features::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[3]);
}

// ===================================================================

class Version::_Internal {
 public:
  using HasBits = decltype(std::declval<Version>()._impl_._has_bits_);
  static void set_has_zephyr_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_zmk_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_app_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::usb::comm::Version_Features& features(const Version* msg);
  static void set_has_features(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::usb::comm::Version_Features&
Version::_Internal::features(const Version* msg) {
  return *msg->_impl_.features_;
}
Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Version* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.zephyr_version_){}
    , decltype(_impl_.zmk_version_){}
    , decltype(_impl_.app_version_){}
    , decltype(_impl_.features_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.zephyr_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.zephyr_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_zephyr_version()) {
    _this->_impl_.zephyr_version_.Set(from._internal_zephyr_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.zmk_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.zmk_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_zmk_version()) {
    _this->_impl_.zmk_version_.Set(from._internal_zmk_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.app_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_version()) {
    _this->_impl_.app_version_.Set(from._internal_app_version(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_features()) {
    _this->_impl_.features_ = new ::usb::comm::Version_Features(*from._impl_.features_);
  }
  // @@protoc_insertion_point(copy_constructor:usb.comm.Version)
}

inline void Version::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.zephyr_version_){}
    , decltype(_impl_.zmk_version_){}
    , decltype(_impl_.app_version_){}
    , decltype(_impl_.features_){nullptr}
  };
  _impl_.zephyr_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.zephyr_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.zmk_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.zmk_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:usb.comm.Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.zephyr_version_.Destroy();
  _impl_.zmk_version_.Destroy();
  _impl_.app_version_.Destroy();
  if (this != internal_default_instance()) delete _impl_.features_;
}

void Version::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.zephyr_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.zmk_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.app_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.features_ != nullptr);
      _impl_.features_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string zephyr_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_zephyr_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "usb.comm.Version.zephyr_version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string zmk_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_zmk_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "usb.comm.Version.zmk_version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string app_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_app_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "usb.comm.Version.app_version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .usb.comm.Version.Features features = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_features(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string zephyr_version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_zephyr_version().data(), static_cast<int>(this->_internal_zephyr_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "usb.comm.Version.zephyr_version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_zephyr_version(), target);
  }

  // required string zmk_version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_zmk_version().data(), static_cast<int>(this->_internal_zmk_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "usb.comm.Version.zmk_version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_zmk_version(), target);
  }

  // required string app_version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_app_version().data(), static_cast<int>(this->_internal_app_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "usb.comm.Version.app_version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_app_version(), target);
  }

  // optional .usb.comm.Version.Features features = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::features(this),
        _Internal::features(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.Version)
  return target;
}

size_t Version::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:usb.comm.Version)
  size_t total_size = 0;

  if (_internal_has_zephyr_version()) {
    // required string zephyr_version = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_zephyr_version());
  }

  if (_internal_has_zmk_version()) {
    // required string zmk_version = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_zmk_version());
  }

  if (_internal_has_app_version()) {
    // required string app_version = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_app_version());
  }

  return total_size;
}
size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.Version)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string zephyr_version = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_zephyr_version());

    // required string zmk_version = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_zmk_version());

    // required string app_version = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_app_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .usb.comm.Version.Features features = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.features_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Version::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Version::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Version::GetClassData() const { return &_class_data_; }


void Version::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.Version)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_zephyr_version(from._internal_zephyr_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_zmk_version(from._internal_zmk_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_app_version(from._internal_app_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_features()->::usb::comm::Version_Features::MergeFrom(
          from._internal_features());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.zephyr_version_, lhs_arena,
      &other->_impl_.zephyr_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.zmk_version_, lhs_arena,
      &other->_impl_.zmk_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_version_, lhs_arena,
      &other->_impl_.app_version_, rhs_arena
  );
  swap(_impl_.features_, other->_impl_.features_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Version::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[4]);
}

// ===================================================================

class MotorState::_Internal {
 public:
  using HasBits = decltype(std::declval<MotorState>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_control_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_current_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_target_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_target_voltage(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

MotorState::MotorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.MotorState)
}
MotorState::MotorState(const MotorState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MotorState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.control_mode_){}
    , decltype(_impl_.current_angle_){}
    , decltype(_impl_.current_velocity_){}
    , decltype(_impl_.target_angle_){}
    , decltype(_impl_.target_velocity_){}
    , decltype(_impl_.target_voltage_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_voltage_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.target_voltage_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.MotorState)
}

inline void MotorState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.control_mode_){0}
    , decltype(_impl_.current_angle_){0}
    , decltype(_impl_.current_velocity_){0}
    , decltype(_impl_.target_angle_){0}
    , decltype(_impl_.target_velocity_){0}
    , decltype(_impl_.target_voltage_){0}
  };
}

MotorState::~MotorState() {
  // @@protoc_insertion_point(destructor:usb.comm.MotorState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MotorState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MotorState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MotorState::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.MotorState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.target_voltage_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.target_voltage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .usb.comm.MotorState.ControlMode control_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::MotorState_ControlMode_IsValid(val))) {
            _internal_set_control_mode(static_cast<::usb::comm::MotorState_ControlMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required float current_angle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_current_angle(&has_bits);
          _impl_.current_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float current_velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_current_velocity(&has_bits);
          _impl_.current_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float target_angle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_target_angle(&has_bits);
          _impl_.target_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float target_velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_target_velocity(&has_bits);
          _impl_.target_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float target_voltage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_target_voltage(&has_bits);
          _impl_.target_voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.MotorState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_timestamp(), target);
  }

  // required .usb.comm.MotorState.ControlMode control_mode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_control_mode(), target);
  }

  // required float current_angle = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_current_angle(), target);
  }

  // required float current_velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_current_velocity(), target);
  }

  // required float target_angle = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_target_angle(), target);
  }

  // required float target_velocity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_target_velocity(), target);
  }

  // required float target_voltage = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_target_voltage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.MotorState)
  return target;
}

size_t MotorState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:usb.comm.MotorState)
  size_t total_size = 0;

  if (_internal_has_timestamp()) {
    // required uint32 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
  }

  if (_internal_has_control_mode()) {
    // required .usb.comm.MotorState.ControlMode control_mode = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_control_mode());
  }

  if (_internal_has_current_angle()) {
    // required float current_angle = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_current_velocity()) {
    // required float current_velocity = 4;
    total_size += 1 + 4;
  }

  if (_internal_has_target_angle()) {
    // required float target_angle = 5;
    total_size += 1 + 4;
  }

  if (_internal_has_target_velocity()) {
    // required float target_velocity = 6;
    total_size += 1 + 4;
  }

  if (_internal_has_target_voltage()) {
    // required float target_voltage = 7;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t MotorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.MotorState)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required uint32 timestamp = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());

    // required .usb.comm.MotorState.ControlMode control_mode = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_control_mode());

    // required float current_angle = 3;
    total_size += 1 + 4;

    // required float current_velocity = 4;
    total_size += 1 + 4;

    // required float target_angle = 5;
    total_size += 1 + 4;

    // required float target_velocity = 6;
    total_size += 1 + 4;

    // required float target_voltage = 7;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MotorState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorState::GetClassData() const { return &_class_data_; }


void MotorState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MotorState*>(&to_msg);
  auto& from = static_cast<const MotorState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.MotorState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.control_mode_ = from._impl_.control_mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.current_angle_ = from._impl_.current_angle_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.current_velocity_ = from._impl_.current_velocity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_angle_ = from._impl_.target_angle_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.target_velocity_ = from._impl_.target_velocity_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.target_voltage_ = from._impl_.target_voltage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorState::CopyFrom(const MotorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.MotorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MotorState::InternalSwap(MotorState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotorState, _impl_.target_voltage_)
      + sizeof(MotorState::_impl_.target_voltage_)
      - PROTOBUF_FIELD_OFFSET(MotorState, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[5]);
}

// ===================================================================

class KnobConfig_Pref::_Internal {
 public:
  using HasBits = decltype(std::declval<KnobConfig_Pref>()._impl_._has_bits_);
  static void set_has_layer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_layer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ppr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_torque_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

KnobConfig_Pref::KnobConfig_Pref(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.KnobConfig.Pref)
}
KnobConfig_Pref::KnobConfig_Pref(const KnobConfig_Pref& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KnobConfig_Pref* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.layer_name_){}
    , decltype(_impl_.layer_id_){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.ppr_){}
    , decltype(_impl_.torque_limit_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.layer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_layer_name()) {
    _this->_impl_.layer_name_.Set(from._internal_layer_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.layer_id_, &from._impl_.layer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.torque_limit_) -
    reinterpret_cast<char*>(&_impl_.layer_id_)) + sizeof(_impl_.torque_limit_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.KnobConfig.Pref)
}

inline void KnobConfig_Pref::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.layer_name_){}
    , decltype(_impl_.layer_id_){0u}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.mode_){0}
    , decltype(_impl_.ppr_){0u}
    , decltype(_impl_.torque_limit_){0}
  };
  _impl_.layer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KnobConfig_Pref::~KnobConfig_Pref() {
  // @@protoc_insertion_point(destructor:usb.comm.KnobConfig.Pref)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KnobConfig_Pref::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layer_name_.Destroy();
}

void KnobConfig_Pref::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KnobConfig_Pref::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.KnobConfig.Pref)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.layer_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.layer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.torque_limit_) -
        reinterpret_cast<char*>(&_impl_.layer_id_)) + sizeof(_impl_.torque_limit_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KnobConfig_Pref::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 layer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_layer_id(&has_bits);
          _impl_.layer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string layer_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_layer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "usb.comm.KnobConfig.Pref.layer_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required bool active = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .usb.comm.KnobConfig.Mode mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::KnobConfig_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::usb::comm::KnobConfig_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ppr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ppr(&has_bits);
          _impl_.ppr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float torque_limit = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_torque_limit(&has_bits);
          _impl_.torque_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KnobConfig_Pref::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.KnobConfig.Pref)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 layer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_layer_id(), target);
  }

  // optional string layer_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_layer_name().data(), static_cast<int>(this->_internal_layer_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "usb.comm.KnobConfig.Pref.layer_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_layer_name(), target);
  }

  // required bool active = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_active(), target);
  }

  // optional .usb.comm.KnobConfig.Mode mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_mode(), target);
  }

  // optional uint32 ppr = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ppr(), target);
  }

  // optional float torque_limit = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_torque_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.KnobConfig.Pref)
  return target;
}

size_t KnobConfig_Pref::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:usb.comm.KnobConfig.Pref)
  size_t total_size = 0;

  if (_internal_has_layer_id()) {
    // required uint32 layer_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_layer_id());
  }

  if (_internal_has_active()) {
    // required bool active = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t KnobConfig_Pref::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.KnobConfig.Pref)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 layer_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_layer_id());

    // required bool active = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string layer_name = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_layer_name());
  }

  if (cached_has_bits & 0x00000038u) {
    // optional .usb.comm.KnobConfig.Mode mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
    }

    // optional uint32 ppr = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ppr());
    }

    // optional float torque_limit = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KnobConfig_Pref::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KnobConfig_Pref::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KnobConfig_Pref::GetClassData() const { return &_class_data_; }


void KnobConfig_Pref::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KnobConfig_Pref*>(&to_msg);
  auto& from = static_cast<const KnobConfig_Pref&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.KnobConfig.Pref)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_layer_name(from._internal_layer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.layer_id_ = from._impl_.layer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ppr_ = from._impl_.ppr_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.torque_limit_ = from._impl_.torque_limit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KnobConfig_Pref::CopyFrom(const KnobConfig_Pref& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.KnobConfig.Pref)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KnobConfig_Pref::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void KnobConfig_Pref::InternalSwap(KnobConfig_Pref* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.layer_name_, lhs_arena,
      &other->_impl_.layer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KnobConfig_Pref, _impl_.torque_limit_)
      + sizeof(KnobConfig_Pref::_impl_.torque_limit_)
      - PROTOBUF_FIELD_OFFSET(KnobConfig_Pref, _impl_.layer_id_)>(
          reinterpret_cast<char*>(&_impl_.layer_id_),
          reinterpret_cast<char*>(&other->_impl_.layer_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KnobConfig_Pref::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[6]);
}

// ===================================================================

class KnobConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<KnobConfig>()._impl_._has_bits_);
  static void set_has_demo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KnobConfig::KnobConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.KnobConfig)
}
KnobConfig::KnobConfig(const KnobConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KnobConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prefs_){from._impl_.prefs_}
    , decltype(_impl_.demo_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.demo_, &from._impl_.demo_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mode_) -
    reinterpret_cast<char*>(&_impl_.demo_)) + sizeof(_impl_.mode_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.KnobConfig)
}

inline void KnobConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prefs_){arena}
    , decltype(_impl_.demo_){false}
    , decltype(_impl_.mode_){0}
  };
}

KnobConfig::~KnobConfig() {
  // @@protoc_insertion_point(destructor:usb.comm.KnobConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KnobConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prefs_.~RepeatedPtrField();
}

void KnobConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KnobConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.KnobConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prefs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.demo_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.demo_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KnobConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool demo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_demo(&has_bits);
          _impl_.demo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .usb.comm.KnobConfig.Mode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::KnobConfig_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::usb::comm::KnobConfig_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .usb.comm.KnobConfig.Pref prefs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prefs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KnobConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.KnobConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool demo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_demo(), target);
  }

  // required .usb.comm.KnobConfig.Mode mode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_mode(), target);
  }

  // repeated .usb.comm.KnobConfig.Pref prefs = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prefs_size()); i < n; i++) {
    const auto& repfield = this->_internal_prefs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.KnobConfig)
  return target;
}

size_t KnobConfig::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:usb.comm.KnobConfig)
  size_t total_size = 0;

  if (_internal_has_demo()) {
    // required bool demo = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_mode()) {
    // required .usb.comm.KnobConfig.Mode mode = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  return total_size;
}
size_t KnobConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.KnobConfig)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bool demo = 1;
    total_size += 1 + 1;

    // required .usb.comm.KnobConfig.Mode mode = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .usb.comm.KnobConfig.Pref prefs = 5;
  total_size += 1UL * this->_internal_prefs_size();
  for (const auto& msg : this->_impl_.prefs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KnobConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KnobConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KnobConfig::GetClassData() const { return &_class_data_; }


void KnobConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KnobConfig*>(&to_msg);
  auto& from = static_cast<const KnobConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.KnobConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prefs_.MergeFrom(from._impl_.prefs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.demo_ = from._impl_.demo_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KnobConfig::CopyFrom(const KnobConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.KnobConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KnobConfig::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.prefs_))
    return false;
  return true;
}

void KnobConfig::InternalSwap(KnobConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.prefs_.InternalSwap(&other->_impl_.prefs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KnobConfig, _impl_.mode_)
      + sizeof(KnobConfig::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(KnobConfig, _impl_.demo_)>(
          reinterpret_cast<char*>(&_impl_.demo_),
          reinterpret_cast<char*>(&other->_impl_.demo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KnobConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[7]);
}

// ===================================================================

class RgbControl::_Internal {
 public:
  using HasBits = decltype(std::declval<RgbControl>()._impl_._has_bits_);
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RgbControl::RgbControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.RgbControl)
}
RgbControl::RgbControl(const RgbControl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RgbControl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.command_ = from._impl_.command_;
  // @@protoc_insertion_point(copy_constructor:usb.comm.RgbControl)
}

inline void RgbControl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){1}
  };
}

RgbControl::~RgbControl() {
  // @@protoc_insertion_point(destructor:usb.comm.RgbControl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RgbControl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RgbControl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RgbControl::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.RgbControl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RgbControl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .usb.comm.RgbControl.Command command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::RgbControl_Command_IsValid(val))) {
            _internal_set_command(static_cast<::usb::comm::RgbControl_Command>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RgbControl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.RgbControl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .usb.comm.RgbControl.Command command = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.RgbControl)
  return target;
}

size_t RgbControl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.RgbControl)
  size_t total_size = 0;

  // required .usb.comm.RgbControl.Command command = 1;
  if (_internal_has_command()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_command());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RgbControl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RgbControl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RgbControl::GetClassData() const { return &_class_data_; }


void RgbControl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RgbControl*>(&to_msg);
  auto& from = static_cast<const RgbControl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.RgbControl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_command()) {
    _this->_internal_set_command(from._internal_command());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RgbControl::CopyFrom(const RgbControl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.RgbControl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RgbControl::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void RgbControl::InternalSwap(RgbControl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.command_, other->_impl_.command_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RgbControl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[8]);
}

// ===================================================================

class RgbState_HSB::_Internal {
 public:
  using HasBits = decltype(std::declval<RgbState_HSB>()._impl_._has_bits_);
  static void set_has_h(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_s(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

RgbState_HSB::RgbState_HSB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.RgbState.HSB)
}
RgbState_HSB::RgbState_HSB(const RgbState_HSB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RgbState_HSB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.h_){}
    , decltype(_impl_.s_){}
    , decltype(_impl_.b_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.h_, &from._impl_.h_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.b_) -
    reinterpret_cast<char*>(&_impl_.h_)) + sizeof(_impl_.b_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.RgbState.HSB)
}

inline void RgbState_HSB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.h_){0u}
    , decltype(_impl_.s_){0u}
    , decltype(_impl_.b_){0u}
  };
}

RgbState_HSB::~RgbState_HSB() {
  // @@protoc_insertion_point(destructor:usb.comm.RgbState.HSB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RgbState_HSB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RgbState_HSB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RgbState_HSB::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.RgbState.HSB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.h_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.b_) -
        reinterpret_cast<char*>(&_impl_.h_)) + sizeof(_impl_.b_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RgbState_HSB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 h = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_h(&has_bits);
          _impl_.h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 s = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_s(&has_bits);
          _impl_.s_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 b = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_b(&has_bits);
          _impl_.b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RgbState_HSB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.RgbState.HSB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 h = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_h(), target);
  }

  // required uint32 s = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_s(), target);
  }

  // required uint32 b = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.RgbState.HSB)
  return target;
}

size_t RgbState_HSB::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:usb.comm.RgbState.HSB)
  size_t total_size = 0;

  if (_internal_has_h()) {
    // required uint32 h = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_h());
  }

  if (_internal_has_s()) {
    // required uint32 s = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_s());
  }

  if (_internal_has_b()) {
    // required uint32 b = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_b());
  }

  return total_size;
}
size_t RgbState_HSB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.RgbState.HSB)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 h = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_h());

    // required uint32 s = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_s());

    // required uint32 b = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_b());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RgbState_HSB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RgbState_HSB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RgbState_HSB::GetClassData() const { return &_class_data_; }


void RgbState_HSB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RgbState_HSB*>(&to_msg);
  auto& from = static_cast<const RgbState_HSB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.RgbState.HSB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.h_ = from._impl_.h_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.s_ = from._impl_.s_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.b_ = from._impl_.b_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RgbState_HSB::CopyFrom(const RgbState_HSB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.RgbState.HSB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RgbState_HSB::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void RgbState_HSB::InternalSwap(RgbState_HSB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RgbState_HSB, _impl_.b_)
      + sizeof(RgbState_HSB::_impl_.b_)
      - PROTOBUF_FIELD_OFFSET(RgbState_HSB, _impl_.h_)>(
          reinterpret_cast<char*>(&_impl_.h_),
          reinterpret_cast<char*>(&other->_impl_.h_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RgbState_HSB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[9]);
}

// ===================================================================

class RgbState::_Internal {
 public:
  using HasBits = decltype(std::declval<RgbState>()._impl_._has_bits_);
  static void set_has_on(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::usb::comm::RgbState_HSB& color(const RgbState* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_effect(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::usb::comm::RgbState_HSB&
RgbState::_Internal::color(const RgbState* msg) {
  return *msg->_impl_.color_;
}
RgbState::RgbState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.RgbState)
}
RgbState::RgbState(const RgbState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RgbState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.on_){}
    , decltype(_impl_.effect_){}
    , decltype(_impl_.speed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::usb::comm::RgbState_HSB(*from._impl_.color_);
  }
  ::memcpy(&_impl_.on_, &from._impl_.on_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.on_)) + sizeof(_impl_.speed_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.RgbState)
}

inline void RgbState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.on_){false}
    , decltype(_impl_.effect_){0}
    , decltype(_impl_.speed_){0u}
  };
}

RgbState::~RgbState() {
  // @@protoc_insertion_point(destructor:usb.comm.RgbState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RgbState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
}

void RgbState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RgbState::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.RgbState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.color_ != nullptr);
    _impl_.color_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.on_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.on_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RgbState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool on = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_on(&has_bits);
          _impl_.on_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .usb.comm.RgbState.HSB color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .usb.comm.RgbState.Effect effect = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::usb::comm::RgbState_Effect_IsValid(val))) {
            _internal_set_effect(static_cast<::usb::comm::RgbState_Effect>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 speed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RgbState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.RgbState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool on = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_on(), target);
  }

  // optional .usb.comm.RgbState.HSB color = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional .usb.comm.RgbState.Effect effect = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_effect(), target);
  }

  // optional uint32 speed = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.RgbState)
  return target;
}

size_t RgbState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.RgbState)
  size_t total_size = 0;

  // required bool on = 1;
  if (_internal_has_on()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .usb.comm.RgbState.HSB color = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional .usb.comm.RgbState.Effect effect = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_effect());
    }

    // optional uint32 speed = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_speed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RgbState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RgbState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RgbState::GetClassData() const { return &_class_data_; }


void RgbState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RgbState*>(&to_msg);
  auto& from = static_cast<const RgbState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.RgbState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::usb::comm::RgbState_HSB::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.on_ = from._impl_.on_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.effect_ = from._impl_.effect_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RgbState::CopyFrom(const RgbState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.RgbState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RgbState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void RgbState::InternalSwap(RgbState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RgbState, _impl_.speed_)
      + sizeof(RgbState::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(RgbState, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RgbState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[10]);
}

// ===================================================================

class RgbIndicator::_Internal {
 public:
  using HasBits = decltype(std::declval<RgbIndicator>()._impl_._has_bits_);
  static void set_has_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brightness_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_brightness_inactive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RgbIndicator::RgbIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.RgbIndicator)
}
RgbIndicator::RgbIndicator(const RgbIndicator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RgbIndicator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_){}
    , decltype(_impl_.brightness_active_){}
    , decltype(_impl_.brightness_inactive_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enable_, &from._impl_.enable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.brightness_inactive_) -
    reinterpret_cast<char*>(&_impl_.enable_)) + sizeof(_impl_.brightness_inactive_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.RgbIndicator)
}

inline void RgbIndicator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_){false}
    , decltype(_impl_.brightness_active_){0u}
    , decltype(_impl_.brightness_inactive_){0u}
  };
}

RgbIndicator::~RgbIndicator() {
  // @@protoc_insertion_point(destructor:usb.comm.RgbIndicator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RgbIndicator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RgbIndicator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RgbIndicator::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.RgbIndicator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.enable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.brightness_inactive_) -
        reinterpret_cast<char*>(&_impl_.enable_)) + sizeof(_impl_.brightness_inactive_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RgbIndicator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable(&has_bits);
          _impl_.enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 brightness_active = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_brightness_active(&has_bits);
          _impl_.brightness_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 brightness_inactive = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_brightness_inactive(&has_bits);
          _impl_.brightness_inactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RgbIndicator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.RgbIndicator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable(), target);
  }

  // optional uint32 brightness_active = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_brightness_active(), target);
  }

  // optional uint32 brightness_inactive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_brightness_inactive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.RgbIndicator)
  return target;
}

size_t RgbIndicator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.RgbIndicator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool enable = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional uint32 brightness_active = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_brightness_active());
    }

    // optional uint32 brightness_inactive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_brightness_inactive());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RgbIndicator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RgbIndicator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RgbIndicator::GetClassData() const { return &_class_data_; }


void RgbIndicator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RgbIndicator*>(&to_msg);
  auto& from = static_cast<const RgbIndicator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.RgbIndicator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.enable_ = from._impl_.enable_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.brightness_active_ = from._impl_.brightness_active_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.brightness_inactive_ = from._impl_.brightness_inactive_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RgbIndicator::CopyFrom(const RgbIndicator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.RgbIndicator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RgbIndicator::IsInitialized() const {
  return true;
}

void RgbIndicator::InternalSwap(RgbIndicator* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RgbIndicator, _impl_.brightness_inactive_)
      + sizeof(RgbIndicator::_impl_.brightness_inactive_)
      - PROTOBUF_FIELD_OFFSET(RgbIndicator, _impl_.enable_)>(
          reinterpret_cast<char*>(&_impl_.enable_),
          reinterpret_cast<char*>(&other->_impl_.enable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RgbIndicator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[11]);
}

// ===================================================================

class EinkImage::_Internal {
 public:
  using HasBits = decltype(std::declval<EinkImage>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bits_length(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

EinkImage::EinkImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:usb.comm.EinkImage)
}
EinkImage::EinkImage(const EinkImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EinkImage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bits_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.bits_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.bits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bits()) {
    _this->_impl_.bits_.Set(from._internal_bits(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bits_length_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.bits_length_));
  // @@protoc_insertion_point(copy_constructor:usb.comm.EinkImage)
}

inline void EinkImage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bits_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.bits_length_){0u}
  };
  _impl_.bits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EinkImage::~EinkImage() {
  // @@protoc_insertion_point(destructor:usb.comm.EinkImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EinkImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bits_.Destroy();
}

void EinkImage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EinkImage::Clear() {
// @@protoc_insertion_point(message_clear_start:usb.comm.EinkImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.bits_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bits_length_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.bits_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EinkImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bits_length = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bits_length(&has_bits);
          _impl_.bits_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bits = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EinkImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:usb.comm.EinkImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional uint32 bits_length = 2 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bits_length(), target);
  }

  // optional bytes bits = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_bits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:usb.comm.EinkImage)
  return target;
}

size_t EinkImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:usb.comm.EinkImage)
  size_t total_size = 0;

  // required uint32 id = 1;
  if (_internal_has_id()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes bits = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_bits());
  }

  // optional uint32 bits_length = 2 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bits_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EinkImage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EinkImage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EinkImage::GetClassData() const { return &_class_data_; }


void EinkImage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EinkImage*>(&to_msg);
  auto& from = static_cast<const EinkImage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:usb.comm.EinkImage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_bits(from._internal_bits());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bits_length_ = from._impl_.bits_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EinkImage::CopyFrom(const EinkImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:usb.comm.EinkImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EinkImage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EinkImage::InternalSwap(EinkImage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bits_, lhs_arena,
      &other->_impl_.bits_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EinkImage, _impl_.bits_length_)
      + sizeof(EinkImage::_impl_.bits_length_)
      - PROTOBUF_FIELD_OFFSET(EinkImage, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EinkImage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_usb_5fcomm_2eproto_getter, &descriptor_table_usb_5fcomm_2eproto_once,
      file_level_metadata_usb_5fcomm_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace comm
}  // namespace usb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::usb::comm::MessageH2D*
Arena::CreateMaybeMessage< ::usb::comm::MessageH2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::MessageH2D >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::MessageD2H*
Arena::CreateMaybeMessage< ::usb::comm::MessageD2H >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::MessageD2H >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::Nop*
Arena::CreateMaybeMessage< ::usb::comm::Nop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::Nop >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::Version_Features*
Arena::CreateMaybeMessage< ::usb::comm::Version_Features >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::Version_Features >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::Version*
Arena::CreateMaybeMessage< ::usb::comm::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::MotorState*
Arena::CreateMaybeMessage< ::usb::comm::MotorState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::MotorState >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::KnobConfig_Pref*
Arena::CreateMaybeMessage< ::usb::comm::KnobConfig_Pref >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::KnobConfig_Pref >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::KnobConfig*
Arena::CreateMaybeMessage< ::usb::comm::KnobConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::KnobConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::RgbControl*
Arena::CreateMaybeMessage< ::usb::comm::RgbControl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::RgbControl >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::RgbState_HSB*
Arena::CreateMaybeMessage< ::usb::comm::RgbState_HSB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::RgbState_HSB >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::RgbState*
Arena::CreateMaybeMessage< ::usb::comm::RgbState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::RgbState >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::RgbIndicator*
Arena::CreateMaybeMessage< ::usb::comm::RgbIndicator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::RgbIndicator >(arena);
}
template<> PROTOBUF_NOINLINE ::usb::comm::EinkImage*
Arena::CreateMaybeMessage< ::usb::comm::EinkImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::usb::comm::EinkImage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
