// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usb_comm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_usb_5fcomm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_usb_5fcomm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_usb_5fcomm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_usb_5fcomm_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_usb_5fcomm_2eproto;
namespace usb {
namespace comm {
class EinkImage;
struct EinkImageDefaultTypeInternal;
extern EinkImageDefaultTypeInternal _EinkImage_default_instance_;
class KnobConfig;
struct KnobConfigDefaultTypeInternal;
extern KnobConfigDefaultTypeInternal _KnobConfig_default_instance_;
class KnobConfig_Pref;
struct KnobConfig_PrefDefaultTypeInternal;
extern KnobConfig_PrefDefaultTypeInternal _KnobConfig_Pref_default_instance_;
class MessageD2H;
struct MessageD2HDefaultTypeInternal;
extern MessageD2HDefaultTypeInternal _MessageD2H_default_instance_;
class MessageH2D;
struct MessageH2DDefaultTypeInternal;
extern MessageH2DDefaultTypeInternal _MessageH2D_default_instance_;
class MotorState;
struct MotorStateDefaultTypeInternal;
extern MotorStateDefaultTypeInternal _MotorState_default_instance_;
class Nop;
struct NopDefaultTypeInternal;
extern NopDefaultTypeInternal _Nop_default_instance_;
class RgbControl;
struct RgbControlDefaultTypeInternal;
extern RgbControlDefaultTypeInternal _RgbControl_default_instance_;
class RgbIndicator;
struct RgbIndicatorDefaultTypeInternal;
extern RgbIndicatorDefaultTypeInternal _RgbIndicator_default_instance_;
class RgbState;
struct RgbStateDefaultTypeInternal;
extern RgbStateDefaultTypeInternal _RgbState_default_instance_;
class RgbState_HSB;
struct RgbState_HSBDefaultTypeInternal;
extern RgbState_HSBDefaultTypeInternal _RgbState_HSB_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class Version_Features;
struct Version_FeaturesDefaultTypeInternal;
extern Version_FeaturesDefaultTypeInternal _Version_Features_default_instance_;
}  // namespace comm
}  // namespace usb
PROTOBUF_NAMESPACE_OPEN
template<> ::usb::comm::EinkImage* Arena::CreateMaybeMessage<::usb::comm::EinkImage>(Arena*);
template<> ::usb::comm::KnobConfig* Arena::CreateMaybeMessage<::usb::comm::KnobConfig>(Arena*);
template<> ::usb::comm::KnobConfig_Pref* Arena::CreateMaybeMessage<::usb::comm::KnobConfig_Pref>(Arena*);
template<> ::usb::comm::MessageD2H* Arena::CreateMaybeMessage<::usb::comm::MessageD2H>(Arena*);
template<> ::usb::comm::MessageH2D* Arena::CreateMaybeMessage<::usb::comm::MessageH2D>(Arena*);
template<> ::usb::comm::MotorState* Arena::CreateMaybeMessage<::usb::comm::MotorState>(Arena*);
template<> ::usb::comm::Nop* Arena::CreateMaybeMessage<::usb::comm::Nop>(Arena*);
template<> ::usb::comm::RgbControl* Arena::CreateMaybeMessage<::usb::comm::RgbControl>(Arena*);
template<> ::usb::comm::RgbIndicator* Arena::CreateMaybeMessage<::usb::comm::RgbIndicator>(Arena*);
template<> ::usb::comm::RgbState* Arena::CreateMaybeMessage<::usb::comm::RgbState>(Arena*);
template<> ::usb::comm::RgbState_HSB* Arena::CreateMaybeMessage<::usb::comm::RgbState_HSB>(Arena*);
template<> ::usb::comm::Version* Arena::CreateMaybeMessage<::usb::comm::Version>(Arena*);
template<> ::usb::comm::Version_Features* Arena::CreateMaybeMessage<::usb::comm::Version_Features>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace usb {
namespace comm {

enum MotorState_ControlMode : int {
  MotorState_ControlMode_TORQUE = 0,
  MotorState_ControlMode_VELOCITY = 1,
  MotorState_ControlMode_ANGLE = 2
};
bool MotorState_ControlMode_IsValid(int value);
constexpr MotorState_ControlMode MotorState_ControlMode_ControlMode_MIN = MotorState_ControlMode_TORQUE;
constexpr MotorState_ControlMode MotorState_ControlMode_ControlMode_MAX = MotorState_ControlMode_ANGLE;
constexpr int MotorState_ControlMode_ControlMode_ARRAYSIZE = MotorState_ControlMode_ControlMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotorState_ControlMode_descriptor();
template<typename T>
inline const std::string& MotorState_ControlMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotorState_ControlMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotorState_ControlMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotorState_ControlMode_descriptor(), enum_t_value);
}
inline bool MotorState_ControlMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotorState_ControlMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotorState_ControlMode>(
    MotorState_ControlMode_descriptor(), name, value);
}
enum KnobConfig_Mode : int {
  KnobConfig_Mode_DISABLE = 0,
  KnobConfig_Mode_INERTIA = 1,
  KnobConfig_Mode_ENCODER = 2,
  KnobConfig_Mode_SPRING = 3,
  KnobConfig_Mode_DAMPED = 4,
  KnobConfig_Mode_SPIN = 5,
  KnobConfig_Mode_RATCHET = 6
};
bool KnobConfig_Mode_IsValid(int value);
constexpr KnobConfig_Mode KnobConfig_Mode_Mode_MIN = KnobConfig_Mode_DISABLE;
constexpr KnobConfig_Mode KnobConfig_Mode_Mode_MAX = KnobConfig_Mode_RATCHET;
constexpr int KnobConfig_Mode_Mode_ARRAYSIZE = KnobConfig_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnobConfig_Mode_descriptor();
template<typename T>
inline const std::string& KnobConfig_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KnobConfig_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KnobConfig_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KnobConfig_Mode_descriptor(), enum_t_value);
}
inline bool KnobConfig_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KnobConfig_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KnobConfig_Mode>(
    KnobConfig_Mode_descriptor(), name, value);
}
enum RgbControl_Command : int {
  RgbControl_Command_RGB_ON = 1,
  RgbControl_Command_RGB_OFF = 2,
  RgbControl_Command_RGB_HUI = 3,
  RgbControl_Command_RGB_HUD = 4,
  RgbControl_Command_RGB_SAI = 5,
  RgbControl_Command_RGB_SAD = 6,
  RgbControl_Command_RGB_BRI = 7,
  RgbControl_Command_RGB_BRD = 8,
  RgbControl_Command_RGB_SPI = 9,
  RgbControl_Command_RGB_SPD = 10,
  RgbControl_Command_RGB_EFF = 11,
  RgbControl_Command_RGB_EFR = 12
};
bool RgbControl_Command_IsValid(int value);
constexpr RgbControl_Command RgbControl_Command_Command_MIN = RgbControl_Command_RGB_ON;
constexpr RgbControl_Command RgbControl_Command_Command_MAX = RgbControl_Command_RGB_EFR;
constexpr int RgbControl_Command_Command_ARRAYSIZE = RgbControl_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RgbControl_Command_descriptor();
template<typename T>
inline const std::string& RgbControl_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RgbControl_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RgbControl_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RgbControl_Command_descriptor(), enum_t_value);
}
inline bool RgbControl_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RgbControl_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RgbControl_Command>(
    RgbControl_Command_descriptor(), name, value);
}
enum RgbState_Effect : int {
  RgbState_Effect_SOLID = 0,
  RgbState_Effect_BREATHE = 1,
  RgbState_Effect_SPECTRUM = 2,
  RgbState_Effect_SWIRL = 3
};
bool RgbState_Effect_IsValid(int value);
constexpr RgbState_Effect RgbState_Effect_Effect_MIN = RgbState_Effect_SOLID;
constexpr RgbState_Effect RgbState_Effect_Effect_MAX = RgbState_Effect_SWIRL;
constexpr int RgbState_Effect_Effect_ARRAYSIZE = RgbState_Effect_Effect_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RgbState_Effect_descriptor();
template<typename T>
inline const std::string& RgbState_Effect_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RgbState_Effect>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RgbState_Effect_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RgbState_Effect_descriptor(), enum_t_value);
}
inline bool RgbState_Effect_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RgbState_Effect* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RgbState_Effect>(
    RgbState_Effect_descriptor(), name, value);
}
enum Action : int {
  NOP = 0,
  VERSION = 1,
  MOTOR_GET_STATE = 2,
  KNOB_GET_CONFIG = 3,
  KNOB_SET_CONFIG = 4,
  KNOB_UPDATE_PREF = 9,
  RGB_CONTROL = 5,
  RGB_GET_STATE = 6,
  RGB_SET_STATE = 8,
  RGB_GET_INDICATOR = 10,
  RGB_SET_INDICATOR = 11,
  EINK_SET_IMAGE = 7
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = NOP;
constexpr Action Action_MAX = RGB_SET_INDICATOR;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
// ===================================================================

class MessageH2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.MessageH2D) */ {
 public:
  inline MessageH2D() : MessageH2D(nullptr) {}
  ~MessageH2D() override;
  explicit PROTOBUF_CONSTEXPR MessageH2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageH2D(const MessageH2D& from);
  MessageH2D(MessageH2D&& from) noexcept
    : MessageH2D() {
    *this = ::std::move(from);
  }

  inline MessageH2D& operator=(const MessageH2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageH2D& operator=(MessageH2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageH2D& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kNop = 2,
    kKnobConfig = 3,
    kKnobPref = 6,
    kRgbControl = 4,
    kRgbState = 7,
    kRgbIndicator = 8,
    kEinkImage = 5,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MessageH2D* internal_default_instance() {
    return reinterpret_cast<const MessageH2D*>(
               &_MessageH2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessageH2D& a, MessageH2D& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageH2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageH2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageH2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageH2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageH2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageH2D& from) {
    MessageH2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageH2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.MessageH2D";
  }
  protected:
  explicit MessageH2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kNopFieldNumber = 2,
    kKnobConfigFieldNumber = 3,
    kKnobPrefFieldNumber = 6,
    kRgbControlFieldNumber = 4,
    kRgbStateFieldNumber = 7,
    kRgbIndicatorFieldNumber = 8,
    kEinkImageFieldNumber = 5,
  };
  // required .usb.comm.Action action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::usb::comm::Action action() const;
  void set_action(::usb::comm::Action value);
  private:
  ::usb::comm::Action _internal_action() const;
  void _internal_set_action(::usb::comm::Action value);
  public:

  // .usb.comm.Nop nop = 2;
  bool has_nop() const;
  private:
  bool _internal_has_nop() const;
  public:
  void clear_nop();
  const ::usb::comm::Nop& nop() const;
  PROTOBUF_NODISCARD ::usb::comm::Nop* release_nop();
  ::usb::comm::Nop* mutable_nop();
  void set_allocated_nop(::usb::comm::Nop* nop);
  private:
  const ::usb::comm::Nop& _internal_nop() const;
  ::usb::comm::Nop* _internal_mutable_nop();
  public:
  void unsafe_arena_set_allocated_nop(
      ::usb::comm::Nop* nop);
  ::usb::comm::Nop* unsafe_arena_release_nop();

  // .usb.comm.KnobConfig knob_config = 3;
  bool has_knob_config() const;
  private:
  bool _internal_has_knob_config() const;
  public:
  void clear_knob_config();
  const ::usb::comm::KnobConfig& knob_config() const;
  PROTOBUF_NODISCARD ::usb::comm::KnobConfig* release_knob_config();
  ::usb::comm::KnobConfig* mutable_knob_config();
  void set_allocated_knob_config(::usb::comm::KnobConfig* knob_config);
  private:
  const ::usb::comm::KnobConfig& _internal_knob_config() const;
  ::usb::comm::KnobConfig* _internal_mutable_knob_config();
  public:
  void unsafe_arena_set_allocated_knob_config(
      ::usb::comm::KnobConfig* knob_config);
  ::usb::comm::KnobConfig* unsafe_arena_release_knob_config();

  // .usb.comm.KnobConfig.Pref knob_pref = 6;
  bool has_knob_pref() const;
  private:
  bool _internal_has_knob_pref() const;
  public:
  void clear_knob_pref();
  const ::usb::comm::KnobConfig_Pref& knob_pref() const;
  PROTOBUF_NODISCARD ::usb::comm::KnobConfig_Pref* release_knob_pref();
  ::usb::comm::KnobConfig_Pref* mutable_knob_pref();
  void set_allocated_knob_pref(::usb::comm::KnobConfig_Pref* knob_pref);
  private:
  const ::usb::comm::KnobConfig_Pref& _internal_knob_pref() const;
  ::usb::comm::KnobConfig_Pref* _internal_mutable_knob_pref();
  public:
  void unsafe_arena_set_allocated_knob_pref(
      ::usb::comm::KnobConfig_Pref* knob_pref);
  ::usb::comm::KnobConfig_Pref* unsafe_arena_release_knob_pref();

  // .usb.comm.RgbControl rgb_control = 4;
  bool has_rgb_control() const;
  private:
  bool _internal_has_rgb_control() const;
  public:
  void clear_rgb_control();
  const ::usb::comm::RgbControl& rgb_control() const;
  PROTOBUF_NODISCARD ::usb::comm::RgbControl* release_rgb_control();
  ::usb::comm::RgbControl* mutable_rgb_control();
  void set_allocated_rgb_control(::usb::comm::RgbControl* rgb_control);
  private:
  const ::usb::comm::RgbControl& _internal_rgb_control() const;
  ::usb::comm::RgbControl* _internal_mutable_rgb_control();
  public:
  void unsafe_arena_set_allocated_rgb_control(
      ::usb::comm::RgbControl* rgb_control);
  ::usb::comm::RgbControl* unsafe_arena_release_rgb_control();

  // .usb.comm.RgbState rgb_state = 7;
  bool has_rgb_state() const;
  private:
  bool _internal_has_rgb_state() const;
  public:
  void clear_rgb_state();
  const ::usb::comm::RgbState& rgb_state() const;
  PROTOBUF_NODISCARD ::usb::comm::RgbState* release_rgb_state();
  ::usb::comm::RgbState* mutable_rgb_state();
  void set_allocated_rgb_state(::usb::comm::RgbState* rgb_state);
  private:
  const ::usb::comm::RgbState& _internal_rgb_state() const;
  ::usb::comm::RgbState* _internal_mutable_rgb_state();
  public:
  void unsafe_arena_set_allocated_rgb_state(
      ::usb::comm::RgbState* rgb_state);
  ::usb::comm::RgbState* unsafe_arena_release_rgb_state();

  // .usb.comm.RgbIndicator rgb_indicator = 8;
  bool has_rgb_indicator() const;
  private:
  bool _internal_has_rgb_indicator() const;
  public:
  void clear_rgb_indicator();
  const ::usb::comm::RgbIndicator& rgb_indicator() const;
  PROTOBUF_NODISCARD ::usb::comm::RgbIndicator* release_rgb_indicator();
  ::usb::comm::RgbIndicator* mutable_rgb_indicator();
  void set_allocated_rgb_indicator(::usb::comm::RgbIndicator* rgb_indicator);
  private:
  const ::usb::comm::RgbIndicator& _internal_rgb_indicator() const;
  ::usb::comm::RgbIndicator* _internal_mutable_rgb_indicator();
  public:
  void unsafe_arena_set_allocated_rgb_indicator(
      ::usb::comm::RgbIndicator* rgb_indicator);
  ::usb::comm::RgbIndicator* unsafe_arena_release_rgb_indicator();

  // .usb.comm.EinkImage eink_image = 5;
  bool has_eink_image() const;
  private:
  bool _internal_has_eink_image() const;
  public:
  void clear_eink_image();
  const ::usb::comm::EinkImage& eink_image() const;
  PROTOBUF_NODISCARD ::usb::comm::EinkImage* release_eink_image();
  ::usb::comm::EinkImage* mutable_eink_image();
  void set_allocated_eink_image(::usb::comm::EinkImage* eink_image);
  private:
  const ::usb::comm::EinkImage& _internal_eink_image() const;
  ::usb::comm::EinkImage* _internal_mutable_eink_image();
  public:
  void unsafe_arena_set_allocated_eink_image(
      ::usb::comm::EinkImage* eink_image);
  ::usb::comm::EinkImage* unsafe_arena_release_eink_image();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:usb.comm.MessageH2D)
 private:
  class _Internal;
  void set_has_nop();
  void set_has_knob_config();
  void set_has_knob_pref();
  void set_has_rgb_control();
  void set_has_rgb_state();
  void set_has_rgb_indicator();
  void set_has_eink_image();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int action_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::usb::comm::Nop* nop_;
      ::usb::comm::KnobConfig* knob_config_;
      ::usb::comm::KnobConfig_Pref* knob_pref_;
      ::usb::comm::RgbControl* rgb_control_;
      ::usb::comm::RgbState* rgb_state_;
      ::usb::comm::RgbIndicator* rgb_indicator_;
      ::usb::comm::EinkImage* eink_image_;
    } payload_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class MessageD2H final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.MessageD2H) */ {
 public:
  inline MessageD2H() : MessageD2H(nullptr) {}
  ~MessageD2H() override;
  explicit PROTOBUF_CONSTEXPR MessageD2H(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageD2H(const MessageD2H& from);
  MessageD2H(MessageD2H&& from) noexcept
    : MessageD2H() {
    *this = ::std::move(from);
  }

  inline MessageD2H& operator=(const MessageD2H& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageD2H& operator=(MessageD2H&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageD2H& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kNop = 2,
    kVersion = 3,
    kMotorState = 4,
    kKnobConfig = 5,
    kKnobPref = 8,
    kRgbState = 6,
    kRgbIndicator = 9,
    kEinkImage = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MessageD2H* internal_default_instance() {
    return reinterpret_cast<const MessageD2H*>(
               &_MessageD2H_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MessageD2H& a, MessageD2H& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageD2H* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageD2H* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageD2H* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageD2H>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageD2H& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageD2H& from) {
    MessageD2H::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageD2H* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.MessageD2H";
  }
  protected:
  explicit MessageD2H(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kNopFieldNumber = 2,
    kVersionFieldNumber = 3,
    kMotorStateFieldNumber = 4,
    kKnobConfigFieldNumber = 5,
    kKnobPrefFieldNumber = 8,
    kRgbStateFieldNumber = 6,
    kRgbIndicatorFieldNumber = 9,
    kEinkImageFieldNumber = 7,
  };
  // required .usb.comm.Action action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::usb::comm::Action action() const;
  void set_action(::usb::comm::Action value);
  private:
  ::usb::comm::Action _internal_action() const;
  void _internal_set_action(::usb::comm::Action value);
  public:

  // .usb.comm.Nop nop = 2;
  bool has_nop() const;
  private:
  bool _internal_has_nop() const;
  public:
  void clear_nop();
  const ::usb::comm::Nop& nop() const;
  PROTOBUF_NODISCARD ::usb::comm::Nop* release_nop();
  ::usb::comm::Nop* mutable_nop();
  void set_allocated_nop(::usb::comm::Nop* nop);
  private:
  const ::usb::comm::Nop& _internal_nop() const;
  ::usb::comm::Nop* _internal_mutable_nop();
  public:
  void unsafe_arena_set_allocated_nop(
      ::usb::comm::Nop* nop);
  ::usb::comm::Nop* unsafe_arena_release_nop();

  // .usb.comm.Version version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::usb::comm::Version& version() const;
  PROTOBUF_NODISCARD ::usb::comm::Version* release_version();
  ::usb::comm::Version* mutable_version();
  void set_allocated_version(::usb::comm::Version* version);
  private:
  const ::usb::comm::Version& _internal_version() const;
  ::usb::comm::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::usb::comm::Version* version);
  ::usb::comm::Version* unsafe_arena_release_version();

  // .usb.comm.MotorState motor_state = 4;
  bool has_motor_state() const;
  private:
  bool _internal_has_motor_state() const;
  public:
  void clear_motor_state();
  const ::usb::comm::MotorState& motor_state() const;
  PROTOBUF_NODISCARD ::usb::comm::MotorState* release_motor_state();
  ::usb::comm::MotorState* mutable_motor_state();
  void set_allocated_motor_state(::usb::comm::MotorState* motor_state);
  private:
  const ::usb::comm::MotorState& _internal_motor_state() const;
  ::usb::comm::MotorState* _internal_mutable_motor_state();
  public:
  void unsafe_arena_set_allocated_motor_state(
      ::usb::comm::MotorState* motor_state);
  ::usb::comm::MotorState* unsafe_arena_release_motor_state();

  // .usb.comm.KnobConfig knob_config = 5;
  bool has_knob_config() const;
  private:
  bool _internal_has_knob_config() const;
  public:
  void clear_knob_config();
  const ::usb::comm::KnobConfig& knob_config() const;
  PROTOBUF_NODISCARD ::usb::comm::KnobConfig* release_knob_config();
  ::usb::comm::KnobConfig* mutable_knob_config();
  void set_allocated_knob_config(::usb::comm::KnobConfig* knob_config);
  private:
  const ::usb::comm::KnobConfig& _internal_knob_config() const;
  ::usb::comm::KnobConfig* _internal_mutable_knob_config();
  public:
  void unsafe_arena_set_allocated_knob_config(
      ::usb::comm::KnobConfig* knob_config);
  ::usb::comm::KnobConfig* unsafe_arena_release_knob_config();

  // .usb.comm.KnobConfig.Pref knob_pref = 8;
  bool has_knob_pref() const;
  private:
  bool _internal_has_knob_pref() const;
  public:
  void clear_knob_pref();
  const ::usb::comm::KnobConfig_Pref& knob_pref() const;
  PROTOBUF_NODISCARD ::usb::comm::KnobConfig_Pref* release_knob_pref();
  ::usb::comm::KnobConfig_Pref* mutable_knob_pref();
  void set_allocated_knob_pref(::usb::comm::KnobConfig_Pref* knob_pref);
  private:
  const ::usb::comm::KnobConfig_Pref& _internal_knob_pref() const;
  ::usb::comm::KnobConfig_Pref* _internal_mutable_knob_pref();
  public:
  void unsafe_arena_set_allocated_knob_pref(
      ::usb::comm::KnobConfig_Pref* knob_pref);
  ::usb::comm::KnobConfig_Pref* unsafe_arena_release_knob_pref();

  // .usb.comm.RgbState rgb_state = 6;
  bool has_rgb_state() const;
  private:
  bool _internal_has_rgb_state() const;
  public:
  void clear_rgb_state();
  const ::usb::comm::RgbState& rgb_state() const;
  PROTOBUF_NODISCARD ::usb::comm::RgbState* release_rgb_state();
  ::usb::comm::RgbState* mutable_rgb_state();
  void set_allocated_rgb_state(::usb::comm::RgbState* rgb_state);
  private:
  const ::usb::comm::RgbState& _internal_rgb_state() const;
  ::usb::comm::RgbState* _internal_mutable_rgb_state();
  public:
  void unsafe_arena_set_allocated_rgb_state(
      ::usb::comm::RgbState* rgb_state);
  ::usb::comm::RgbState* unsafe_arena_release_rgb_state();

  // .usb.comm.RgbIndicator rgb_indicator = 9;
  bool has_rgb_indicator() const;
  private:
  bool _internal_has_rgb_indicator() const;
  public:
  void clear_rgb_indicator();
  const ::usb::comm::RgbIndicator& rgb_indicator() const;
  PROTOBUF_NODISCARD ::usb::comm::RgbIndicator* release_rgb_indicator();
  ::usb::comm::RgbIndicator* mutable_rgb_indicator();
  void set_allocated_rgb_indicator(::usb::comm::RgbIndicator* rgb_indicator);
  private:
  const ::usb::comm::RgbIndicator& _internal_rgb_indicator() const;
  ::usb::comm::RgbIndicator* _internal_mutable_rgb_indicator();
  public:
  void unsafe_arena_set_allocated_rgb_indicator(
      ::usb::comm::RgbIndicator* rgb_indicator);
  ::usb::comm::RgbIndicator* unsafe_arena_release_rgb_indicator();

  // .usb.comm.EinkImage eink_image = 7;
  bool has_eink_image() const;
  private:
  bool _internal_has_eink_image() const;
  public:
  void clear_eink_image();
  const ::usb::comm::EinkImage& eink_image() const;
  PROTOBUF_NODISCARD ::usb::comm::EinkImage* release_eink_image();
  ::usb::comm::EinkImage* mutable_eink_image();
  void set_allocated_eink_image(::usb::comm::EinkImage* eink_image);
  private:
  const ::usb::comm::EinkImage& _internal_eink_image() const;
  ::usb::comm::EinkImage* _internal_mutable_eink_image();
  public:
  void unsafe_arena_set_allocated_eink_image(
      ::usb::comm::EinkImage* eink_image);
  ::usb::comm::EinkImage* unsafe_arena_release_eink_image();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:usb.comm.MessageD2H)
 private:
  class _Internal;
  void set_has_nop();
  void set_has_version();
  void set_has_motor_state();
  void set_has_knob_config();
  void set_has_knob_pref();
  void set_has_rgb_state();
  void set_has_rgb_indicator();
  void set_has_eink_image();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int action_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::usb::comm::Nop* nop_;
      ::usb::comm::Version* version_;
      ::usb::comm::MotorState* motor_state_;
      ::usb::comm::KnobConfig* knob_config_;
      ::usb::comm::KnobConfig_Pref* knob_pref_;
      ::usb::comm::RgbState* rgb_state_;
      ::usb::comm::RgbIndicator* rgb_indicator_;
      ::usb::comm::EinkImage* eink_image_;
    } payload_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class Nop final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:usb.comm.Nop) */ {
 public:
  inline Nop() : Nop(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Nop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Nop(const Nop& from);
  Nop(Nop&& from) noexcept
    : Nop() {
    *this = ::std::move(from);
  }

  inline Nop& operator=(const Nop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nop& operator=(Nop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Nop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Nop* internal_default_instance() {
    return reinterpret_cast<const Nop*>(
               &_Nop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Nop& a, Nop& b) {
    a.Swap(&b);
  }
  inline void Swap(Nop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Nop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Nop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Nop& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Nop& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.Nop";
  }
  protected:
  explicit Nop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:usb.comm.Nop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class Version_Features final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.Version.Features) */ {
 public:
  inline Version_Features() : Version_Features(nullptr) {}
  ~Version_Features() override;
  explicit PROTOBUF_CONSTEXPR Version_Features(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version_Features(const Version_Features& from);
  Version_Features(Version_Features&& from) noexcept
    : Version_Features() {
    *this = ::std::move(from);
  }

  inline Version_Features& operator=(const Version_Features& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version_Features& operator=(Version_Features&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version_Features& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version_Features* internal_default_instance() {
    return reinterpret_cast<const Version_Features*>(
               &_Version_Features_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Version_Features& a, Version_Features& b) {
    a.Swap(&b);
  }
  inline void Swap(Version_Features* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version_Features* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version_Features* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version_Features>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version_Features& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version_Features& from) {
    Version_Features::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version_Features* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.Version.Features";
  }
  protected:
  explicit Version_Features(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRgbFieldNumber = 1,
    kRgbFullControlFieldNumber = 5,
    kRgbIndicatorFieldNumber = 6,
    kEinkFieldNumber = 2,
    kKnobFieldNumber = 3,
    kKnobPrefsFieldNumber = 4,
  };
  // optional bool rgb = 1;
  bool has_rgb() const;
  private:
  bool _internal_has_rgb() const;
  public:
  void clear_rgb();
  bool rgb() const;
  void set_rgb(bool value);
  private:
  bool _internal_rgb() const;
  void _internal_set_rgb(bool value);
  public:

  // optional bool rgb_full_control = 5;
  bool has_rgb_full_control() const;
  private:
  bool _internal_has_rgb_full_control() const;
  public:
  void clear_rgb_full_control();
  bool rgb_full_control() const;
  void set_rgb_full_control(bool value);
  private:
  bool _internal_rgb_full_control() const;
  void _internal_set_rgb_full_control(bool value);
  public:

  // optional bool rgb_indicator = 6;
  bool has_rgb_indicator() const;
  private:
  bool _internal_has_rgb_indicator() const;
  public:
  void clear_rgb_indicator();
  bool rgb_indicator() const;
  void set_rgb_indicator(bool value);
  private:
  bool _internal_rgb_indicator() const;
  void _internal_set_rgb_indicator(bool value);
  public:

  // optional bool eink = 2;
  bool has_eink() const;
  private:
  bool _internal_has_eink() const;
  public:
  void clear_eink();
  bool eink() const;
  void set_eink(bool value);
  private:
  bool _internal_eink() const;
  void _internal_set_eink(bool value);
  public:

  // optional bool knob = 3;
  bool has_knob() const;
  private:
  bool _internal_has_knob() const;
  public:
  void clear_knob();
  bool knob() const;
  void set_knob(bool value);
  private:
  bool _internal_knob() const;
  void _internal_set_knob(bool value);
  public:

  // optional bool knob_prefs = 4;
  bool has_knob_prefs() const;
  private:
  bool _internal_has_knob_prefs() const;
  public:
  void clear_knob_prefs();
  bool knob_prefs() const;
  void set_knob_prefs(bool value);
  private:
  bool _internal_knob_prefs() const;
  void _internal_set_knob_prefs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.Version.Features)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool rgb_;
    bool rgb_full_control_;
    bool rgb_indicator_;
    bool eink_;
    bool knob_;
    bool knob_prefs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Version_Features Features;

  // accessors -------------------------------------------------------

  enum : int {
    kZephyrVersionFieldNumber = 1,
    kZmkVersionFieldNumber = 2,
    kAppVersionFieldNumber = 3,
    kFeaturesFieldNumber = 4,
  };
  // required string zephyr_version = 1;
  bool has_zephyr_version() const;
  private:
  bool _internal_has_zephyr_version() const;
  public:
  void clear_zephyr_version();
  const std::string& zephyr_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zephyr_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zephyr_version();
  PROTOBUF_NODISCARD std::string* release_zephyr_version();
  void set_allocated_zephyr_version(std::string* zephyr_version);
  private:
  const std::string& _internal_zephyr_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zephyr_version(const std::string& value);
  std::string* _internal_mutable_zephyr_version();
  public:

  // required string zmk_version = 2;
  bool has_zmk_version() const;
  private:
  bool _internal_has_zmk_version() const;
  public:
  void clear_zmk_version();
  const std::string& zmk_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zmk_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zmk_version();
  PROTOBUF_NODISCARD std::string* release_zmk_version();
  void set_allocated_zmk_version(std::string* zmk_version);
  private:
  const std::string& _internal_zmk_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zmk_version(const std::string& value);
  std::string* _internal_mutable_zmk_version();
  public:

  // required string app_version = 3;
  bool has_app_version() const;
  private:
  bool _internal_has_app_version() const;
  public:
  void clear_app_version();
  const std::string& app_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_version();
  PROTOBUF_NODISCARD std::string* release_app_version();
  void set_allocated_app_version(std::string* app_version);
  private:
  const std::string& _internal_app_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_version(const std::string& value);
  std::string* _internal_mutable_app_version();
  public:

  // optional .usb.comm.Version.Features features = 4;
  bool has_features() const;
  private:
  bool _internal_has_features() const;
  public:
  void clear_features();
  const ::usb::comm::Version_Features& features() const;
  PROTOBUF_NODISCARD ::usb::comm::Version_Features* release_features();
  ::usb::comm::Version_Features* mutable_features();
  void set_allocated_features(::usb::comm::Version_Features* features);
  private:
  const ::usb::comm::Version_Features& _internal_features() const;
  ::usb::comm::Version_Features* _internal_mutable_features();
  public:
  void unsafe_arena_set_allocated_features(
      ::usb::comm::Version_Features* features);
  ::usb::comm::Version_Features* unsafe_arena_release_features();

  // @@protoc_insertion_point(class_scope:usb.comm.Version)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zephyr_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zmk_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_version_;
    ::usb::comm::Version_Features* features_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class MotorState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.MotorState) */ {
 public:
  inline MotorState() : MotorState(nullptr) {}
  ~MotorState() override;
  explicit PROTOBUF_CONSTEXPR MotorState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorState(const MotorState& from);
  MotorState(MotorState&& from) noexcept
    : MotorState() {
    *this = ::std::move(from);
  }

  inline MotorState& operator=(const MotorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorState& operator=(MotorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorState* internal_default_instance() {
    return reinterpret_cast<const MotorState*>(
               &_MotorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MotorState& a, MotorState& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MotorState& from) {
    MotorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.MotorState";
  }
  protected:
  explicit MotorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MotorState_ControlMode ControlMode;
  static constexpr ControlMode TORQUE =
    MotorState_ControlMode_TORQUE;
  static constexpr ControlMode VELOCITY =
    MotorState_ControlMode_VELOCITY;
  static constexpr ControlMode ANGLE =
    MotorState_ControlMode_ANGLE;
  static inline bool ControlMode_IsValid(int value) {
    return MotorState_ControlMode_IsValid(value);
  }
  static constexpr ControlMode ControlMode_MIN =
    MotorState_ControlMode_ControlMode_MIN;
  static constexpr ControlMode ControlMode_MAX =
    MotorState_ControlMode_ControlMode_MAX;
  static constexpr int ControlMode_ARRAYSIZE =
    MotorState_ControlMode_ControlMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ControlMode_descriptor() {
    return MotorState_ControlMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ControlMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ControlMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ControlMode_Name.");
    return MotorState_ControlMode_Name(enum_t_value);
  }
  static inline bool ControlMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ControlMode* value) {
    return MotorState_ControlMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kControlModeFieldNumber = 2,
    kCurrentAngleFieldNumber = 3,
    kCurrentVelocityFieldNumber = 4,
    kTargetAngleFieldNumber = 5,
    kTargetVelocityFieldNumber = 6,
    kTargetVoltageFieldNumber = 7,
  };
  // required uint32 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // required .usb.comm.MotorState.ControlMode control_mode = 2;
  bool has_control_mode() const;
  private:
  bool _internal_has_control_mode() const;
  public:
  void clear_control_mode();
  ::usb::comm::MotorState_ControlMode control_mode() const;
  void set_control_mode(::usb::comm::MotorState_ControlMode value);
  private:
  ::usb::comm::MotorState_ControlMode _internal_control_mode() const;
  void _internal_set_control_mode(::usb::comm::MotorState_ControlMode value);
  public:

  // required float current_angle = 3;
  bool has_current_angle() const;
  private:
  bool _internal_has_current_angle() const;
  public:
  void clear_current_angle();
  float current_angle() const;
  void set_current_angle(float value);
  private:
  float _internal_current_angle() const;
  void _internal_set_current_angle(float value);
  public:

  // required float current_velocity = 4;
  bool has_current_velocity() const;
  private:
  bool _internal_has_current_velocity() const;
  public:
  void clear_current_velocity();
  float current_velocity() const;
  void set_current_velocity(float value);
  private:
  float _internal_current_velocity() const;
  void _internal_set_current_velocity(float value);
  public:

  // required float target_angle = 5;
  bool has_target_angle() const;
  private:
  bool _internal_has_target_angle() const;
  public:
  void clear_target_angle();
  float target_angle() const;
  void set_target_angle(float value);
  private:
  float _internal_target_angle() const;
  void _internal_set_target_angle(float value);
  public:

  // required float target_velocity = 6;
  bool has_target_velocity() const;
  private:
  bool _internal_has_target_velocity() const;
  public:
  void clear_target_velocity();
  float target_velocity() const;
  void set_target_velocity(float value);
  private:
  float _internal_target_velocity() const;
  void _internal_set_target_velocity(float value);
  public:

  // required float target_voltage = 7;
  bool has_target_voltage() const;
  private:
  bool _internal_has_target_voltage() const;
  public:
  void clear_target_voltage();
  float target_voltage() const;
  void set_target_voltage(float value);
  private:
  float _internal_target_voltage() const;
  void _internal_set_target_voltage(float value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.MotorState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t timestamp_;
    int control_mode_;
    float current_angle_;
    float current_velocity_;
    float target_angle_;
    float target_velocity_;
    float target_voltage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class KnobConfig_Pref final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.KnobConfig.Pref) */ {
 public:
  inline KnobConfig_Pref() : KnobConfig_Pref(nullptr) {}
  ~KnobConfig_Pref() override;
  explicit PROTOBUF_CONSTEXPR KnobConfig_Pref(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KnobConfig_Pref(const KnobConfig_Pref& from);
  KnobConfig_Pref(KnobConfig_Pref&& from) noexcept
    : KnobConfig_Pref() {
    *this = ::std::move(from);
  }

  inline KnobConfig_Pref& operator=(const KnobConfig_Pref& from) {
    CopyFrom(from);
    return *this;
  }
  inline KnobConfig_Pref& operator=(KnobConfig_Pref&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KnobConfig_Pref& default_instance() {
    return *internal_default_instance();
  }
  static inline const KnobConfig_Pref* internal_default_instance() {
    return reinterpret_cast<const KnobConfig_Pref*>(
               &_KnobConfig_Pref_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KnobConfig_Pref& a, KnobConfig_Pref& b) {
    a.Swap(&b);
  }
  inline void Swap(KnobConfig_Pref* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KnobConfig_Pref* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KnobConfig_Pref* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KnobConfig_Pref>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KnobConfig_Pref& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KnobConfig_Pref& from) {
    KnobConfig_Pref::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KnobConfig_Pref* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.KnobConfig.Pref";
  }
  protected:
  explicit KnobConfig_Pref(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerNameFieldNumber = 2,
    kLayerIdFieldNumber = 1,
    kActiveFieldNumber = 3,
    kModeFieldNumber = 4,
    kPprFieldNumber = 5,
    kTorqueLimitFieldNumber = 6,
  };
  // optional string layer_name = 2;
  bool has_layer_name() const;
  private:
  bool _internal_has_layer_name() const;
  public:
  void clear_layer_name();
  const std::string& layer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layer_name();
  PROTOBUF_NODISCARD std::string* release_layer_name();
  void set_allocated_layer_name(std::string* layer_name);
  private:
  const std::string& _internal_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layer_name(const std::string& value);
  std::string* _internal_mutable_layer_name();
  public:

  // required uint32 layer_id = 1;
  bool has_layer_id() const;
  private:
  bool _internal_has_layer_id() const;
  public:
  void clear_layer_id();
  uint32_t layer_id() const;
  void set_layer_id(uint32_t value);
  private:
  uint32_t _internal_layer_id() const;
  void _internal_set_layer_id(uint32_t value);
  public:

  // required bool active = 3;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional .usb.comm.KnobConfig.Mode mode = 4;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::usb::comm::KnobConfig_Mode mode() const;
  void set_mode(::usb::comm::KnobConfig_Mode value);
  private:
  ::usb::comm::KnobConfig_Mode _internal_mode() const;
  void _internal_set_mode(::usb::comm::KnobConfig_Mode value);
  public:

  // optional uint32 ppr = 5;
  bool has_ppr() const;
  private:
  bool _internal_has_ppr() const;
  public:
  void clear_ppr();
  uint32_t ppr() const;
  void set_ppr(uint32_t value);
  private:
  uint32_t _internal_ppr() const;
  void _internal_set_ppr(uint32_t value);
  public:

  // optional float torque_limit = 6;
  bool has_torque_limit() const;
  private:
  bool _internal_has_torque_limit() const;
  public:
  void clear_torque_limit();
  float torque_limit() const;
  void set_torque_limit(float value);
  private:
  float _internal_torque_limit() const;
  void _internal_set_torque_limit(float value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.KnobConfig.Pref)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layer_name_;
    uint32_t layer_id_;
    bool active_;
    int mode_;
    uint32_t ppr_;
    float torque_limit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class KnobConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.KnobConfig) */ {
 public:
  inline KnobConfig() : KnobConfig(nullptr) {}
  ~KnobConfig() override;
  explicit PROTOBUF_CONSTEXPR KnobConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KnobConfig(const KnobConfig& from);
  KnobConfig(KnobConfig&& from) noexcept
    : KnobConfig() {
    *this = ::std::move(from);
  }

  inline KnobConfig& operator=(const KnobConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline KnobConfig& operator=(KnobConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KnobConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const KnobConfig* internal_default_instance() {
    return reinterpret_cast<const KnobConfig*>(
               &_KnobConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(KnobConfig& a, KnobConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(KnobConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KnobConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KnobConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KnobConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KnobConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KnobConfig& from) {
    KnobConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KnobConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.KnobConfig";
  }
  protected:
  explicit KnobConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KnobConfig_Pref Pref;

  typedef KnobConfig_Mode Mode;
  static constexpr Mode DISABLE =
    KnobConfig_Mode_DISABLE;
  static constexpr Mode INERTIA =
    KnobConfig_Mode_INERTIA;
  static constexpr Mode ENCODER =
    KnobConfig_Mode_ENCODER;
  static constexpr Mode SPRING =
    KnobConfig_Mode_SPRING;
  static constexpr Mode DAMPED =
    KnobConfig_Mode_DAMPED;
  static constexpr Mode SPIN =
    KnobConfig_Mode_SPIN;
  static constexpr Mode RATCHET =
    KnobConfig_Mode_RATCHET;
  static inline bool Mode_IsValid(int value) {
    return KnobConfig_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    KnobConfig_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    KnobConfig_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    KnobConfig_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return KnobConfig_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return KnobConfig_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return KnobConfig_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPrefsFieldNumber = 5,
    kDemoFieldNumber = 1,
    kModeFieldNumber = 2,
  };
  // repeated .usb.comm.KnobConfig.Pref prefs = 5;
  int prefs_size() const;
  private:
  int _internal_prefs_size() const;
  public:
  void clear_prefs();
  ::usb::comm::KnobConfig_Pref* mutable_prefs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::usb::comm::KnobConfig_Pref >*
      mutable_prefs();
  private:
  const ::usb::comm::KnobConfig_Pref& _internal_prefs(int index) const;
  ::usb::comm::KnobConfig_Pref* _internal_add_prefs();
  public:
  const ::usb::comm::KnobConfig_Pref& prefs(int index) const;
  ::usb::comm::KnobConfig_Pref* add_prefs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::usb::comm::KnobConfig_Pref >&
      prefs() const;

  // required bool demo = 1;
  bool has_demo() const;
  private:
  bool _internal_has_demo() const;
  public:
  void clear_demo();
  bool demo() const;
  void set_demo(bool value);
  private:
  bool _internal_demo() const;
  void _internal_set_demo(bool value);
  public:

  // required .usb.comm.KnobConfig.Mode mode = 2;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::usb::comm::KnobConfig_Mode mode() const;
  void set_mode(::usb::comm::KnobConfig_Mode value);
  private:
  ::usb::comm::KnobConfig_Mode _internal_mode() const;
  void _internal_set_mode(::usb::comm::KnobConfig_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.KnobConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::usb::comm::KnobConfig_Pref > prefs_;
    bool demo_;
    int mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class RgbControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.RgbControl) */ {
 public:
  inline RgbControl() : RgbControl(nullptr) {}
  ~RgbControl() override;
  explicit PROTOBUF_CONSTEXPR RgbControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RgbControl(const RgbControl& from);
  RgbControl(RgbControl&& from) noexcept
    : RgbControl() {
    *this = ::std::move(from);
  }

  inline RgbControl& operator=(const RgbControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RgbControl& operator=(RgbControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RgbControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const RgbControl* internal_default_instance() {
    return reinterpret_cast<const RgbControl*>(
               &_RgbControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RgbControl& a, RgbControl& b) {
    a.Swap(&b);
  }
  inline void Swap(RgbControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RgbControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RgbControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RgbControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RgbControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RgbControl& from) {
    RgbControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RgbControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.RgbControl";
  }
  protected:
  explicit RgbControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RgbControl_Command Command;
  static constexpr Command RGB_ON =
    RgbControl_Command_RGB_ON;
  static constexpr Command RGB_OFF =
    RgbControl_Command_RGB_OFF;
  static constexpr Command RGB_HUI =
    RgbControl_Command_RGB_HUI;
  static constexpr Command RGB_HUD =
    RgbControl_Command_RGB_HUD;
  static constexpr Command RGB_SAI =
    RgbControl_Command_RGB_SAI;
  static constexpr Command RGB_SAD =
    RgbControl_Command_RGB_SAD;
  static constexpr Command RGB_BRI =
    RgbControl_Command_RGB_BRI;
  static constexpr Command RGB_BRD =
    RgbControl_Command_RGB_BRD;
  static constexpr Command RGB_SPI =
    RgbControl_Command_RGB_SPI;
  static constexpr Command RGB_SPD =
    RgbControl_Command_RGB_SPD;
  static constexpr Command RGB_EFF =
    RgbControl_Command_RGB_EFF;
  static constexpr Command RGB_EFR =
    RgbControl_Command_RGB_EFR;
  static inline bool Command_IsValid(int value) {
    return RgbControl_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    RgbControl_Command_Command_MIN;
  static constexpr Command Command_MAX =
    RgbControl_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    RgbControl_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return RgbControl_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return RgbControl_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return RgbControl_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // required .usb.comm.RgbControl.Command command = 1;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  ::usb::comm::RgbControl_Command command() const;
  void set_command(::usb::comm::RgbControl_Command value);
  private:
  ::usb::comm::RgbControl_Command _internal_command() const;
  void _internal_set_command(::usb::comm::RgbControl_Command value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.RgbControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int command_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class RgbState_HSB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.RgbState.HSB) */ {
 public:
  inline RgbState_HSB() : RgbState_HSB(nullptr) {}
  ~RgbState_HSB() override;
  explicit PROTOBUF_CONSTEXPR RgbState_HSB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RgbState_HSB(const RgbState_HSB& from);
  RgbState_HSB(RgbState_HSB&& from) noexcept
    : RgbState_HSB() {
    *this = ::std::move(from);
  }

  inline RgbState_HSB& operator=(const RgbState_HSB& from) {
    CopyFrom(from);
    return *this;
  }
  inline RgbState_HSB& operator=(RgbState_HSB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RgbState_HSB& default_instance() {
    return *internal_default_instance();
  }
  static inline const RgbState_HSB* internal_default_instance() {
    return reinterpret_cast<const RgbState_HSB*>(
               &_RgbState_HSB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RgbState_HSB& a, RgbState_HSB& b) {
    a.Swap(&b);
  }
  inline void Swap(RgbState_HSB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RgbState_HSB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RgbState_HSB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RgbState_HSB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RgbState_HSB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RgbState_HSB& from) {
    RgbState_HSB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RgbState_HSB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.RgbState.HSB";
  }
  protected:
  explicit RgbState_HSB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHFieldNumber = 1,
    kSFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // required uint32 h = 1;
  bool has_h() const;
  private:
  bool _internal_has_h() const;
  public:
  void clear_h();
  uint32_t h() const;
  void set_h(uint32_t value);
  private:
  uint32_t _internal_h() const;
  void _internal_set_h(uint32_t value);
  public:

  // required uint32 s = 2;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  uint32_t s() const;
  void set_s(uint32_t value);
  private:
  uint32_t _internal_s() const;
  void _internal_set_s(uint32_t value);
  public:

  // required uint32 b = 3;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  uint32_t b() const;
  void set_b(uint32_t value);
  private:
  uint32_t _internal_b() const;
  void _internal_set_b(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.RgbState.HSB)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t h_;
    uint32_t s_;
    uint32_t b_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class RgbState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.RgbState) */ {
 public:
  inline RgbState() : RgbState(nullptr) {}
  ~RgbState() override;
  explicit PROTOBUF_CONSTEXPR RgbState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RgbState(const RgbState& from);
  RgbState(RgbState&& from) noexcept
    : RgbState() {
    *this = ::std::move(from);
  }

  inline RgbState& operator=(const RgbState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RgbState& operator=(RgbState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RgbState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RgbState* internal_default_instance() {
    return reinterpret_cast<const RgbState*>(
               &_RgbState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RgbState& a, RgbState& b) {
    a.Swap(&b);
  }
  inline void Swap(RgbState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RgbState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RgbState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RgbState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RgbState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RgbState& from) {
    RgbState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RgbState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.RgbState";
  }
  protected:
  explicit RgbState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RgbState_HSB HSB;

  typedef RgbState_Effect Effect;
  static constexpr Effect SOLID =
    RgbState_Effect_SOLID;
  static constexpr Effect BREATHE =
    RgbState_Effect_BREATHE;
  static constexpr Effect SPECTRUM =
    RgbState_Effect_SPECTRUM;
  static constexpr Effect SWIRL =
    RgbState_Effect_SWIRL;
  static inline bool Effect_IsValid(int value) {
    return RgbState_Effect_IsValid(value);
  }
  static constexpr Effect Effect_MIN =
    RgbState_Effect_Effect_MIN;
  static constexpr Effect Effect_MAX =
    RgbState_Effect_Effect_MAX;
  static constexpr int Effect_ARRAYSIZE =
    RgbState_Effect_Effect_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Effect_descriptor() {
    return RgbState_Effect_descriptor();
  }
  template<typename T>
  static inline const std::string& Effect_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Effect>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Effect_Name.");
    return RgbState_Effect_Name(enum_t_value);
  }
  static inline bool Effect_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Effect* value) {
    return RgbState_Effect_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 2,
    kOnFieldNumber = 1,
    kEffectFieldNumber = 3,
    kSpeedFieldNumber = 4,
  };
  // optional .usb.comm.RgbState.HSB color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::usb::comm::RgbState_HSB& color() const;
  PROTOBUF_NODISCARD ::usb::comm::RgbState_HSB* release_color();
  ::usb::comm::RgbState_HSB* mutable_color();
  void set_allocated_color(::usb::comm::RgbState_HSB* color);
  private:
  const ::usb::comm::RgbState_HSB& _internal_color() const;
  ::usb::comm::RgbState_HSB* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::usb::comm::RgbState_HSB* color);
  ::usb::comm::RgbState_HSB* unsafe_arena_release_color();

  // required bool on = 1;
  bool has_on() const;
  private:
  bool _internal_has_on() const;
  public:
  void clear_on();
  bool on() const;
  void set_on(bool value);
  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);
  public:

  // optional .usb.comm.RgbState.Effect effect = 3;
  bool has_effect() const;
  private:
  bool _internal_has_effect() const;
  public:
  void clear_effect();
  ::usb::comm::RgbState_Effect effect() const;
  void set_effect(::usb::comm::RgbState_Effect value);
  private:
  ::usb::comm::RgbState_Effect _internal_effect() const;
  void _internal_set_effect(::usb::comm::RgbState_Effect value);
  public:

  // optional uint32 speed = 4;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.RgbState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::usb::comm::RgbState_HSB* color_;
    bool on_;
    int effect_;
    uint32_t speed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class RgbIndicator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.RgbIndicator) */ {
 public:
  inline RgbIndicator() : RgbIndicator(nullptr) {}
  ~RgbIndicator() override;
  explicit PROTOBUF_CONSTEXPR RgbIndicator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RgbIndicator(const RgbIndicator& from);
  RgbIndicator(RgbIndicator&& from) noexcept
    : RgbIndicator() {
    *this = ::std::move(from);
  }

  inline RgbIndicator& operator=(const RgbIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline RgbIndicator& operator=(RgbIndicator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RgbIndicator& default_instance() {
    return *internal_default_instance();
  }
  static inline const RgbIndicator* internal_default_instance() {
    return reinterpret_cast<const RgbIndicator*>(
               &_RgbIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RgbIndicator& a, RgbIndicator& b) {
    a.Swap(&b);
  }
  inline void Swap(RgbIndicator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RgbIndicator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RgbIndicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RgbIndicator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RgbIndicator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RgbIndicator& from) {
    RgbIndicator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RgbIndicator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.RgbIndicator";
  }
  protected:
  explicit RgbIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
    kBrightnessActiveFieldNumber = 2,
    kBrightnessInactiveFieldNumber = 3,
  };
  // optional bool enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional uint32 brightness_active = 2;
  bool has_brightness_active() const;
  private:
  bool _internal_has_brightness_active() const;
  public:
  void clear_brightness_active();
  uint32_t brightness_active() const;
  void set_brightness_active(uint32_t value);
  private:
  uint32_t _internal_brightness_active() const;
  void _internal_set_brightness_active(uint32_t value);
  public:

  // optional uint32 brightness_inactive = 3;
  bool has_brightness_inactive() const;
  private:
  bool _internal_has_brightness_inactive() const;
  public:
  void clear_brightness_inactive();
  uint32_t brightness_inactive() const;
  void set_brightness_inactive(uint32_t value);
  private:
  uint32_t _internal_brightness_inactive() const;
  void _internal_set_brightness_inactive(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.RgbIndicator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_;
    uint32_t brightness_active_;
    uint32_t brightness_inactive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// -------------------------------------------------------------------

class EinkImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usb.comm.EinkImage) */ {
 public:
  inline EinkImage() : EinkImage(nullptr) {}
  ~EinkImage() override;
  explicit PROTOBUF_CONSTEXPR EinkImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EinkImage(const EinkImage& from);
  EinkImage(EinkImage&& from) noexcept
    : EinkImage() {
    *this = ::std::move(from);
  }

  inline EinkImage& operator=(const EinkImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EinkImage& operator=(EinkImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EinkImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EinkImage* internal_default_instance() {
    return reinterpret_cast<const EinkImage*>(
               &_EinkImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EinkImage& a, EinkImage& b) {
    a.Swap(&b);
  }
  inline void Swap(EinkImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EinkImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EinkImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EinkImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EinkImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EinkImage& from) {
    EinkImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EinkImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usb.comm.EinkImage";
  }
  protected:
  explicit EinkImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitsFieldNumber = 3,
    kIdFieldNumber = 1,
    kBitsLengthFieldNumber = 2,
  };
  // optional bytes bits = 3;
  bool has_bits() const;
  private:
  bool _internal_has_bits() const;
  public:
  void clear_bits();
  const std::string& bits() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bits(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bits();
  PROTOBUF_NODISCARD std::string* release_bits();
  void set_allocated_bits(std::string* bits);
  private:
  const std::string& _internal_bits() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bits(const std::string& value);
  std::string* _internal_mutable_bits();
  public:

  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // optional uint32 bits_length = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_bits_length() const;
  private:
  bool _internal_has_bits_length() const;
  public:
  PROTOBUF_DEPRECATED void clear_bits_length();
  PROTOBUF_DEPRECATED uint32_t bits_length() const;
  PROTOBUF_DEPRECATED void set_bits_length(uint32_t value);
  private:
  uint32_t _internal_bits_length() const;
  void _internal_set_bits_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:usb.comm.EinkImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bits_;
    uint32_t id_;
    uint32_t bits_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usb_5fcomm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MessageH2D

// required .usb.comm.Action action = 1;
inline bool MessageH2D::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageH2D::has_action() const {
  return _internal_has_action();
}
inline void MessageH2D::clear_action() {
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::usb::comm::Action MessageH2D::_internal_action() const {
  return static_cast< ::usb::comm::Action >(_impl_.action_);
}
inline ::usb::comm::Action MessageH2D::action() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.action)
  return _internal_action();
}
inline void MessageH2D::_internal_set_action(::usb::comm::Action value) {
  assert(::usb::comm::Action_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_ = value;
}
inline void MessageH2D::set_action(::usb::comm::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:usb.comm.MessageH2D.action)
}

// .usb.comm.Nop nop = 2;
inline bool MessageH2D::_internal_has_nop() const {
  return payload_case() == kNop;
}
inline bool MessageH2D::has_nop() const {
  return _internal_has_nop();
}
inline void MessageH2D::set_has_nop() {
  _impl_._oneof_case_[0] = kNop;
}
inline void MessageH2D::clear_nop() {
  if (_internal_has_nop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.nop_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::Nop* MessageH2D::release_nop() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.nop)
  if (_internal_has_nop()) {
    clear_has_payload();
    ::usb::comm::Nop* temp = _impl_.payload_.nop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::Nop& MessageH2D::_internal_nop() const {
  return _internal_has_nop()
      ? *_impl_.payload_.nop_
      : reinterpret_cast< ::usb::comm::Nop&>(::usb::comm::_Nop_default_instance_);
}
inline const ::usb::comm::Nop& MessageH2D::nop() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.nop)
  return _internal_nop();
}
inline ::usb::comm::Nop* MessageH2D::unsafe_arena_release_nop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.nop)
  if (_internal_has_nop()) {
    clear_has_payload();
    ::usb::comm::Nop* temp = _impl_.payload_.nop_;
    _impl_.payload_.nop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_nop(::usb::comm::Nop* nop) {
  clear_payload();
  if (nop) {
    set_has_nop();
    _impl_.payload_.nop_ = nop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.nop)
}
inline ::usb::comm::Nop* MessageH2D::_internal_mutable_nop() {
  if (!_internal_has_nop()) {
    clear_payload();
    set_has_nop();
    _impl_.payload_.nop_ = CreateMaybeMessage< ::usb::comm::Nop >(GetArenaForAllocation());
  }
  return _impl_.payload_.nop_;
}
inline ::usb::comm::Nop* MessageH2D::mutable_nop() {
  ::usb::comm::Nop* _msg = _internal_mutable_nop();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.nop)
  return _msg;
}

// .usb.comm.KnobConfig knob_config = 3;
inline bool MessageH2D::_internal_has_knob_config() const {
  return payload_case() == kKnobConfig;
}
inline bool MessageH2D::has_knob_config() const {
  return _internal_has_knob_config();
}
inline void MessageH2D::set_has_knob_config() {
  _impl_._oneof_case_[0] = kKnobConfig;
}
inline void MessageH2D::clear_knob_config() {
  if (_internal_has_knob_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.knob_config_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::KnobConfig* MessageH2D::release_knob_config() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.knob_config)
  if (_internal_has_knob_config()) {
    clear_has_payload();
    ::usb::comm::KnobConfig* temp = _impl_.payload_.knob_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.knob_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::KnobConfig& MessageH2D::_internal_knob_config() const {
  return _internal_has_knob_config()
      ? *_impl_.payload_.knob_config_
      : reinterpret_cast< ::usb::comm::KnobConfig&>(::usb::comm::_KnobConfig_default_instance_);
}
inline const ::usb::comm::KnobConfig& MessageH2D::knob_config() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.knob_config)
  return _internal_knob_config();
}
inline ::usb::comm::KnobConfig* MessageH2D::unsafe_arena_release_knob_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.knob_config)
  if (_internal_has_knob_config()) {
    clear_has_payload();
    ::usb::comm::KnobConfig* temp = _impl_.payload_.knob_config_;
    _impl_.payload_.knob_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_knob_config(::usb::comm::KnobConfig* knob_config) {
  clear_payload();
  if (knob_config) {
    set_has_knob_config();
    _impl_.payload_.knob_config_ = knob_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.knob_config)
}
inline ::usb::comm::KnobConfig* MessageH2D::_internal_mutable_knob_config() {
  if (!_internal_has_knob_config()) {
    clear_payload();
    set_has_knob_config();
    _impl_.payload_.knob_config_ = CreateMaybeMessage< ::usb::comm::KnobConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_.knob_config_;
}
inline ::usb::comm::KnobConfig* MessageH2D::mutable_knob_config() {
  ::usb::comm::KnobConfig* _msg = _internal_mutable_knob_config();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.knob_config)
  return _msg;
}

// .usb.comm.KnobConfig.Pref knob_pref = 6;
inline bool MessageH2D::_internal_has_knob_pref() const {
  return payload_case() == kKnobPref;
}
inline bool MessageH2D::has_knob_pref() const {
  return _internal_has_knob_pref();
}
inline void MessageH2D::set_has_knob_pref() {
  _impl_._oneof_case_[0] = kKnobPref;
}
inline void MessageH2D::clear_knob_pref() {
  if (_internal_has_knob_pref()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.knob_pref_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::KnobConfig_Pref* MessageH2D::release_knob_pref() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.knob_pref)
  if (_internal_has_knob_pref()) {
    clear_has_payload();
    ::usb::comm::KnobConfig_Pref* temp = _impl_.payload_.knob_pref_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.knob_pref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::KnobConfig_Pref& MessageH2D::_internal_knob_pref() const {
  return _internal_has_knob_pref()
      ? *_impl_.payload_.knob_pref_
      : reinterpret_cast< ::usb::comm::KnobConfig_Pref&>(::usb::comm::_KnobConfig_Pref_default_instance_);
}
inline const ::usb::comm::KnobConfig_Pref& MessageH2D::knob_pref() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.knob_pref)
  return _internal_knob_pref();
}
inline ::usb::comm::KnobConfig_Pref* MessageH2D::unsafe_arena_release_knob_pref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.knob_pref)
  if (_internal_has_knob_pref()) {
    clear_has_payload();
    ::usb::comm::KnobConfig_Pref* temp = _impl_.payload_.knob_pref_;
    _impl_.payload_.knob_pref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_knob_pref(::usb::comm::KnobConfig_Pref* knob_pref) {
  clear_payload();
  if (knob_pref) {
    set_has_knob_pref();
    _impl_.payload_.knob_pref_ = knob_pref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.knob_pref)
}
inline ::usb::comm::KnobConfig_Pref* MessageH2D::_internal_mutable_knob_pref() {
  if (!_internal_has_knob_pref()) {
    clear_payload();
    set_has_knob_pref();
    _impl_.payload_.knob_pref_ = CreateMaybeMessage< ::usb::comm::KnobConfig_Pref >(GetArenaForAllocation());
  }
  return _impl_.payload_.knob_pref_;
}
inline ::usb::comm::KnobConfig_Pref* MessageH2D::mutable_knob_pref() {
  ::usb::comm::KnobConfig_Pref* _msg = _internal_mutable_knob_pref();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.knob_pref)
  return _msg;
}

// .usb.comm.RgbControl rgb_control = 4;
inline bool MessageH2D::_internal_has_rgb_control() const {
  return payload_case() == kRgbControl;
}
inline bool MessageH2D::has_rgb_control() const {
  return _internal_has_rgb_control();
}
inline void MessageH2D::set_has_rgb_control() {
  _impl_._oneof_case_[0] = kRgbControl;
}
inline void MessageH2D::clear_rgb_control() {
  if (_internal_has_rgb_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rgb_control_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::RgbControl* MessageH2D::release_rgb_control() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.rgb_control)
  if (_internal_has_rgb_control()) {
    clear_has_payload();
    ::usb::comm::RgbControl* temp = _impl_.payload_.rgb_control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rgb_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::RgbControl& MessageH2D::_internal_rgb_control() const {
  return _internal_has_rgb_control()
      ? *_impl_.payload_.rgb_control_
      : reinterpret_cast< ::usb::comm::RgbControl&>(::usb::comm::_RgbControl_default_instance_);
}
inline const ::usb::comm::RgbControl& MessageH2D::rgb_control() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.rgb_control)
  return _internal_rgb_control();
}
inline ::usb::comm::RgbControl* MessageH2D::unsafe_arena_release_rgb_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.rgb_control)
  if (_internal_has_rgb_control()) {
    clear_has_payload();
    ::usb::comm::RgbControl* temp = _impl_.payload_.rgb_control_;
    _impl_.payload_.rgb_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_rgb_control(::usb::comm::RgbControl* rgb_control) {
  clear_payload();
  if (rgb_control) {
    set_has_rgb_control();
    _impl_.payload_.rgb_control_ = rgb_control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.rgb_control)
}
inline ::usb::comm::RgbControl* MessageH2D::_internal_mutable_rgb_control() {
  if (!_internal_has_rgb_control()) {
    clear_payload();
    set_has_rgb_control();
    _impl_.payload_.rgb_control_ = CreateMaybeMessage< ::usb::comm::RgbControl >(GetArenaForAllocation());
  }
  return _impl_.payload_.rgb_control_;
}
inline ::usb::comm::RgbControl* MessageH2D::mutable_rgb_control() {
  ::usb::comm::RgbControl* _msg = _internal_mutable_rgb_control();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.rgb_control)
  return _msg;
}

// .usb.comm.RgbState rgb_state = 7;
inline bool MessageH2D::_internal_has_rgb_state() const {
  return payload_case() == kRgbState;
}
inline bool MessageH2D::has_rgb_state() const {
  return _internal_has_rgb_state();
}
inline void MessageH2D::set_has_rgb_state() {
  _impl_._oneof_case_[0] = kRgbState;
}
inline void MessageH2D::clear_rgb_state() {
  if (_internal_has_rgb_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rgb_state_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::RgbState* MessageH2D::release_rgb_state() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.rgb_state)
  if (_internal_has_rgb_state()) {
    clear_has_payload();
    ::usb::comm::RgbState* temp = _impl_.payload_.rgb_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rgb_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::RgbState& MessageH2D::_internal_rgb_state() const {
  return _internal_has_rgb_state()
      ? *_impl_.payload_.rgb_state_
      : reinterpret_cast< ::usb::comm::RgbState&>(::usb::comm::_RgbState_default_instance_);
}
inline const ::usb::comm::RgbState& MessageH2D::rgb_state() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.rgb_state)
  return _internal_rgb_state();
}
inline ::usb::comm::RgbState* MessageH2D::unsafe_arena_release_rgb_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.rgb_state)
  if (_internal_has_rgb_state()) {
    clear_has_payload();
    ::usb::comm::RgbState* temp = _impl_.payload_.rgb_state_;
    _impl_.payload_.rgb_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_rgb_state(::usb::comm::RgbState* rgb_state) {
  clear_payload();
  if (rgb_state) {
    set_has_rgb_state();
    _impl_.payload_.rgb_state_ = rgb_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.rgb_state)
}
inline ::usb::comm::RgbState* MessageH2D::_internal_mutable_rgb_state() {
  if (!_internal_has_rgb_state()) {
    clear_payload();
    set_has_rgb_state();
    _impl_.payload_.rgb_state_ = CreateMaybeMessage< ::usb::comm::RgbState >(GetArenaForAllocation());
  }
  return _impl_.payload_.rgb_state_;
}
inline ::usb::comm::RgbState* MessageH2D::mutable_rgb_state() {
  ::usb::comm::RgbState* _msg = _internal_mutable_rgb_state();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.rgb_state)
  return _msg;
}

// .usb.comm.RgbIndicator rgb_indicator = 8;
inline bool MessageH2D::_internal_has_rgb_indicator() const {
  return payload_case() == kRgbIndicator;
}
inline bool MessageH2D::has_rgb_indicator() const {
  return _internal_has_rgb_indicator();
}
inline void MessageH2D::set_has_rgb_indicator() {
  _impl_._oneof_case_[0] = kRgbIndicator;
}
inline void MessageH2D::clear_rgb_indicator() {
  if (_internal_has_rgb_indicator()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rgb_indicator_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::RgbIndicator* MessageH2D::release_rgb_indicator() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.rgb_indicator)
  if (_internal_has_rgb_indicator()) {
    clear_has_payload();
    ::usb::comm::RgbIndicator* temp = _impl_.payload_.rgb_indicator_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rgb_indicator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::RgbIndicator& MessageH2D::_internal_rgb_indicator() const {
  return _internal_has_rgb_indicator()
      ? *_impl_.payload_.rgb_indicator_
      : reinterpret_cast< ::usb::comm::RgbIndicator&>(::usb::comm::_RgbIndicator_default_instance_);
}
inline const ::usb::comm::RgbIndicator& MessageH2D::rgb_indicator() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.rgb_indicator)
  return _internal_rgb_indicator();
}
inline ::usb::comm::RgbIndicator* MessageH2D::unsafe_arena_release_rgb_indicator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.rgb_indicator)
  if (_internal_has_rgb_indicator()) {
    clear_has_payload();
    ::usb::comm::RgbIndicator* temp = _impl_.payload_.rgb_indicator_;
    _impl_.payload_.rgb_indicator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_rgb_indicator(::usb::comm::RgbIndicator* rgb_indicator) {
  clear_payload();
  if (rgb_indicator) {
    set_has_rgb_indicator();
    _impl_.payload_.rgb_indicator_ = rgb_indicator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.rgb_indicator)
}
inline ::usb::comm::RgbIndicator* MessageH2D::_internal_mutable_rgb_indicator() {
  if (!_internal_has_rgb_indicator()) {
    clear_payload();
    set_has_rgb_indicator();
    _impl_.payload_.rgb_indicator_ = CreateMaybeMessage< ::usb::comm::RgbIndicator >(GetArenaForAllocation());
  }
  return _impl_.payload_.rgb_indicator_;
}
inline ::usb::comm::RgbIndicator* MessageH2D::mutable_rgb_indicator() {
  ::usb::comm::RgbIndicator* _msg = _internal_mutable_rgb_indicator();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.rgb_indicator)
  return _msg;
}

// .usb.comm.EinkImage eink_image = 5;
inline bool MessageH2D::_internal_has_eink_image() const {
  return payload_case() == kEinkImage;
}
inline bool MessageH2D::has_eink_image() const {
  return _internal_has_eink_image();
}
inline void MessageH2D::set_has_eink_image() {
  _impl_._oneof_case_[0] = kEinkImage;
}
inline void MessageH2D::clear_eink_image() {
  if (_internal_has_eink_image()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.eink_image_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::EinkImage* MessageH2D::release_eink_image() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageH2D.eink_image)
  if (_internal_has_eink_image()) {
    clear_has_payload();
    ::usb::comm::EinkImage* temp = _impl_.payload_.eink_image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.eink_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::EinkImage& MessageH2D::_internal_eink_image() const {
  return _internal_has_eink_image()
      ? *_impl_.payload_.eink_image_
      : reinterpret_cast< ::usb::comm::EinkImage&>(::usb::comm::_EinkImage_default_instance_);
}
inline const ::usb::comm::EinkImage& MessageH2D::eink_image() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageH2D.eink_image)
  return _internal_eink_image();
}
inline ::usb::comm::EinkImage* MessageH2D::unsafe_arena_release_eink_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageH2D.eink_image)
  if (_internal_has_eink_image()) {
    clear_has_payload();
    ::usb::comm::EinkImage* temp = _impl_.payload_.eink_image_;
    _impl_.payload_.eink_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageH2D::unsafe_arena_set_allocated_eink_image(::usb::comm::EinkImage* eink_image) {
  clear_payload();
  if (eink_image) {
    set_has_eink_image();
    _impl_.payload_.eink_image_ = eink_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageH2D.eink_image)
}
inline ::usb::comm::EinkImage* MessageH2D::_internal_mutable_eink_image() {
  if (!_internal_has_eink_image()) {
    clear_payload();
    set_has_eink_image();
    _impl_.payload_.eink_image_ = CreateMaybeMessage< ::usb::comm::EinkImage >(GetArenaForAllocation());
  }
  return _impl_.payload_.eink_image_;
}
inline ::usb::comm::EinkImage* MessageH2D::mutable_eink_image() {
  ::usb::comm::EinkImage* _msg = _internal_mutable_eink_image();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageH2D.eink_image)
  return _msg;
}

inline bool MessageH2D::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MessageH2D::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MessageH2D::PayloadCase MessageH2D::payload_case() const {
  return MessageH2D::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MessageD2H

// required .usb.comm.Action action = 1;
inline bool MessageD2H::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageD2H::has_action() const {
  return _internal_has_action();
}
inline void MessageD2H::clear_action() {
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::usb::comm::Action MessageD2H::_internal_action() const {
  return static_cast< ::usb::comm::Action >(_impl_.action_);
}
inline ::usb::comm::Action MessageD2H::action() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.action)
  return _internal_action();
}
inline void MessageD2H::_internal_set_action(::usb::comm::Action value) {
  assert(::usb::comm::Action_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_ = value;
}
inline void MessageD2H::set_action(::usb::comm::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:usb.comm.MessageD2H.action)
}

// .usb.comm.Nop nop = 2;
inline bool MessageD2H::_internal_has_nop() const {
  return payload_case() == kNop;
}
inline bool MessageD2H::has_nop() const {
  return _internal_has_nop();
}
inline void MessageD2H::set_has_nop() {
  _impl_._oneof_case_[0] = kNop;
}
inline void MessageD2H::clear_nop() {
  if (_internal_has_nop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.nop_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::Nop* MessageD2H::release_nop() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.nop)
  if (_internal_has_nop()) {
    clear_has_payload();
    ::usb::comm::Nop* temp = _impl_.payload_.nop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::Nop& MessageD2H::_internal_nop() const {
  return _internal_has_nop()
      ? *_impl_.payload_.nop_
      : reinterpret_cast< ::usb::comm::Nop&>(::usb::comm::_Nop_default_instance_);
}
inline const ::usb::comm::Nop& MessageD2H::nop() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.nop)
  return _internal_nop();
}
inline ::usb::comm::Nop* MessageD2H::unsafe_arena_release_nop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.nop)
  if (_internal_has_nop()) {
    clear_has_payload();
    ::usb::comm::Nop* temp = _impl_.payload_.nop_;
    _impl_.payload_.nop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_nop(::usb::comm::Nop* nop) {
  clear_payload();
  if (nop) {
    set_has_nop();
    _impl_.payload_.nop_ = nop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.nop)
}
inline ::usb::comm::Nop* MessageD2H::_internal_mutable_nop() {
  if (!_internal_has_nop()) {
    clear_payload();
    set_has_nop();
    _impl_.payload_.nop_ = CreateMaybeMessage< ::usb::comm::Nop >(GetArenaForAllocation());
  }
  return _impl_.payload_.nop_;
}
inline ::usb::comm::Nop* MessageD2H::mutable_nop() {
  ::usb::comm::Nop* _msg = _internal_mutable_nop();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.nop)
  return _msg;
}

// .usb.comm.Version version = 3;
inline bool MessageD2H::_internal_has_version() const {
  return payload_case() == kVersion;
}
inline bool MessageD2H::has_version() const {
  return _internal_has_version();
}
inline void MessageD2H::set_has_version() {
  _impl_._oneof_case_[0] = kVersion;
}
inline void MessageD2H::clear_version() {
  if (_internal_has_version()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.version_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::Version* MessageD2H::release_version() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.version)
  if (_internal_has_version()) {
    clear_has_payload();
    ::usb::comm::Version* temp = _impl_.payload_.version_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::Version& MessageD2H::_internal_version() const {
  return _internal_has_version()
      ? *_impl_.payload_.version_
      : reinterpret_cast< ::usb::comm::Version&>(::usb::comm::_Version_default_instance_);
}
inline const ::usb::comm::Version& MessageD2H::version() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.version)
  return _internal_version();
}
inline ::usb::comm::Version* MessageD2H::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.version)
  if (_internal_has_version()) {
    clear_has_payload();
    ::usb::comm::Version* temp = _impl_.payload_.version_;
    _impl_.payload_.version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_version(::usb::comm::Version* version) {
  clear_payload();
  if (version) {
    set_has_version();
    _impl_.payload_.version_ = version;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.version)
}
inline ::usb::comm::Version* MessageD2H::_internal_mutable_version() {
  if (!_internal_has_version()) {
    clear_payload();
    set_has_version();
    _impl_.payload_.version_ = CreateMaybeMessage< ::usb::comm::Version >(GetArenaForAllocation());
  }
  return _impl_.payload_.version_;
}
inline ::usb::comm::Version* MessageD2H::mutable_version() {
  ::usb::comm::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.version)
  return _msg;
}

// .usb.comm.MotorState motor_state = 4;
inline bool MessageD2H::_internal_has_motor_state() const {
  return payload_case() == kMotorState;
}
inline bool MessageD2H::has_motor_state() const {
  return _internal_has_motor_state();
}
inline void MessageD2H::set_has_motor_state() {
  _impl_._oneof_case_[0] = kMotorState;
}
inline void MessageD2H::clear_motor_state() {
  if (_internal_has_motor_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.motor_state_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::MotorState* MessageD2H::release_motor_state() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.motor_state)
  if (_internal_has_motor_state()) {
    clear_has_payload();
    ::usb::comm::MotorState* temp = _impl_.payload_.motor_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.motor_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::MotorState& MessageD2H::_internal_motor_state() const {
  return _internal_has_motor_state()
      ? *_impl_.payload_.motor_state_
      : reinterpret_cast< ::usb::comm::MotorState&>(::usb::comm::_MotorState_default_instance_);
}
inline const ::usb::comm::MotorState& MessageD2H::motor_state() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.motor_state)
  return _internal_motor_state();
}
inline ::usb::comm::MotorState* MessageD2H::unsafe_arena_release_motor_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.motor_state)
  if (_internal_has_motor_state()) {
    clear_has_payload();
    ::usb::comm::MotorState* temp = _impl_.payload_.motor_state_;
    _impl_.payload_.motor_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_motor_state(::usb::comm::MotorState* motor_state) {
  clear_payload();
  if (motor_state) {
    set_has_motor_state();
    _impl_.payload_.motor_state_ = motor_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.motor_state)
}
inline ::usb::comm::MotorState* MessageD2H::_internal_mutable_motor_state() {
  if (!_internal_has_motor_state()) {
    clear_payload();
    set_has_motor_state();
    _impl_.payload_.motor_state_ = CreateMaybeMessage< ::usb::comm::MotorState >(GetArenaForAllocation());
  }
  return _impl_.payload_.motor_state_;
}
inline ::usb::comm::MotorState* MessageD2H::mutable_motor_state() {
  ::usb::comm::MotorState* _msg = _internal_mutable_motor_state();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.motor_state)
  return _msg;
}

// .usb.comm.KnobConfig knob_config = 5;
inline bool MessageD2H::_internal_has_knob_config() const {
  return payload_case() == kKnobConfig;
}
inline bool MessageD2H::has_knob_config() const {
  return _internal_has_knob_config();
}
inline void MessageD2H::set_has_knob_config() {
  _impl_._oneof_case_[0] = kKnobConfig;
}
inline void MessageD2H::clear_knob_config() {
  if (_internal_has_knob_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.knob_config_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::KnobConfig* MessageD2H::release_knob_config() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.knob_config)
  if (_internal_has_knob_config()) {
    clear_has_payload();
    ::usb::comm::KnobConfig* temp = _impl_.payload_.knob_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.knob_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::KnobConfig& MessageD2H::_internal_knob_config() const {
  return _internal_has_knob_config()
      ? *_impl_.payload_.knob_config_
      : reinterpret_cast< ::usb::comm::KnobConfig&>(::usb::comm::_KnobConfig_default_instance_);
}
inline const ::usb::comm::KnobConfig& MessageD2H::knob_config() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.knob_config)
  return _internal_knob_config();
}
inline ::usb::comm::KnobConfig* MessageD2H::unsafe_arena_release_knob_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.knob_config)
  if (_internal_has_knob_config()) {
    clear_has_payload();
    ::usb::comm::KnobConfig* temp = _impl_.payload_.knob_config_;
    _impl_.payload_.knob_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_knob_config(::usb::comm::KnobConfig* knob_config) {
  clear_payload();
  if (knob_config) {
    set_has_knob_config();
    _impl_.payload_.knob_config_ = knob_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.knob_config)
}
inline ::usb::comm::KnobConfig* MessageD2H::_internal_mutable_knob_config() {
  if (!_internal_has_knob_config()) {
    clear_payload();
    set_has_knob_config();
    _impl_.payload_.knob_config_ = CreateMaybeMessage< ::usb::comm::KnobConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_.knob_config_;
}
inline ::usb::comm::KnobConfig* MessageD2H::mutable_knob_config() {
  ::usb::comm::KnobConfig* _msg = _internal_mutable_knob_config();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.knob_config)
  return _msg;
}

// .usb.comm.KnobConfig.Pref knob_pref = 8;
inline bool MessageD2H::_internal_has_knob_pref() const {
  return payload_case() == kKnobPref;
}
inline bool MessageD2H::has_knob_pref() const {
  return _internal_has_knob_pref();
}
inline void MessageD2H::set_has_knob_pref() {
  _impl_._oneof_case_[0] = kKnobPref;
}
inline void MessageD2H::clear_knob_pref() {
  if (_internal_has_knob_pref()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.knob_pref_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::KnobConfig_Pref* MessageD2H::release_knob_pref() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.knob_pref)
  if (_internal_has_knob_pref()) {
    clear_has_payload();
    ::usb::comm::KnobConfig_Pref* temp = _impl_.payload_.knob_pref_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.knob_pref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::KnobConfig_Pref& MessageD2H::_internal_knob_pref() const {
  return _internal_has_knob_pref()
      ? *_impl_.payload_.knob_pref_
      : reinterpret_cast< ::usb::comm::KnobConfig_Pref&>(::usb::comm::_KnobConfig_Pref_default_instance_);
}
inline const ::usb::comm::KnobConfig_Pref& MessageD2H::knob_pref() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.knob_pref)
  return _internal_knob_pref();
}
inline ::usb::comm::KnobConfig_Pref* MessageD2H::unsafe_arena_release_knob_pref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.knob_pref)
  if (_internal_has_knob_pref()) {
    clear_has_payload();
    ::usb::comm::KnobConfig_Pref* temp = _impl_.payload_.knob_pref_;
    _impl_.payload_.knob_pref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_knob_pref(::usb::comm::KnobConfig_Pref* knob_pref) {
  clear_payload();
  if (knob_pref) {
    set_has_knob_pref();
    _impl_.payload_.knob_pref_ = knob_pref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.knob_pref)
}
inline ::usb::comm::KnobConfig_Pref* MessageD2H::_internal_mutable_knob_pref() {
  if (!_internal_has_knob_pref()) {
    clear_payload();
    set_has_knob_pref();
    _impl_.payload_.knob_pref_ = CreateMaybeMessage< ::usb::comm::KnobConfig_Pref >(GetArenaForAllocation());
  }
  return _impl_.payload_.knob_pref_;
}
inline ::usb::comm::KnobConfig_Pref* MessageD2H::mutable_knob_pref() {
  ::usb::comm::KnobConfig_Pref* _msg = _internal_mutable_knob_pref();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.knob_pref)
  return _msg;
}

// .usb.comm.RgbState rgb_state = 6;
inline bool MessageD2H::_internal_has_rgb_state() const {
  return payload_case() == kRgbState;
}
inline bool MessageD2H::has_rgb_state() const {
  return _internal_has_rgb_state();
}
inline void MessageD2H::set_has_rgb_state() {
  _impl_._oneof_case_[0] = kRgbState;
}
inline void MessageD2H::clear_rgb_state() {
  if (_internal_has_rgb_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rgb_state_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::RgbState* MessageD2H::release_rgb_state() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.rgb_state)
  if (_internal_has_rgb_state()) {
    clear_has_payload();
    ::usb::comm::RgbState* temp = _impl_.payload_.rgb_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rgb_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::RgbState& MessageD2H::_internal_rgb_state() const {
  return _internal_has_rgb_state()
      ? *_impl_.payload_.rgb_state_
      : reinterpret_cast< ::usb::comm::RgbState&>(::usb::comm::_RgbState_default_instance_);
}
inline const ::usb::comm::RgbState& MessageD2H::rgb_state() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.rgb_state)
  return _internal_rgb_state();
}
inline ::usb::comm::RgbState* MessageD2H::unsafe_arena_release_rgb_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.rgb_state)
  if (_internal_has_rgb_state()) {
    clear_has_payload();
    ::usb::comm::RgbState* temp = _impl_.payload_.rgb_state_;
    _impl_.payload_.rgb_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_rgb_state(::usb::comm::RgbState* rgb_state) {
  clear_payload();
  if (rgb_state) {
    set_has_rgb_state();
    _impl_.payload_.rgb_state_ = rgb_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.rgb_state)
}
inline ::usb::comm::RgbState* MessageD2H::_internal_mutable_rgb_state() {
  if (!_internal_has_rgb_state()) {
    clear_payload();
    set_has_rgb_state();
    _impl_.payload_.rgb_state_ = CreateMaybeMessage< ::usb::comm::RgbState >(GetArenaForAllocation());
  }
  return _impl_.payload_.rgb_state_;
}
inline ::usb::comm::RgbState* MessageD2H::mutable_rgb_state() {
  ::usb::comm::RgbState* _msg = _internal_mutable_rgb_state();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.rgb_state)
  return _msg;
}

// .usb.comm.RgbIndicator rgb_indicator = 9;
inline bool MessageD2H::_internal_has_rgb_indicator() const {
  return payload_case() == kRgbIndicator;
}
inline bool MessageD2H::has_rgb_indicator() const {
  return _internal_has_rgb_indicator();
}
inline void MessageD2H::set_has_rgb_indicator() {
  _impl_._oneof_case_[0] = kRgbIndicator;
}
inline void MessageD2H::clear_rgb_indicator() {
  if (_internal_has_rgb_indicator()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rgb_indicator_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::RgbIndicator* MessageD2H::release_rgb_indicator() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.rgb_indicator)
  if (_internal_has_rgb_indicator()) {
    clear_has_payload();
    ::usb::comm::RgbIndicator* temp = _impl_.payload_.rgb_indicator_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rgb_indicator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::RgbIndicator& MessageD2H::_internal_rgb_indicator() const {
  return _internal_has_rgb_indicator()
      ? *_impl_.payload_.rgb_indicator_
      : reinterpret_cast< ::usb::comm::RgbIndicator&>(::usb::comm::_RgbIndicator_default_instance_);
}
inline const ::usb::comm::RgbIndicator& MessageD2H::rgb_indicator() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.rgb_indicator)
  return _internal_rgb_indicator();
}
inline ::usb::comm::RgbIndicator* MessageD2H::unsafe_arena_release_rgb_indicator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.rgb_indicator)
  if (_internal_has_rgb_indicator()) {
    clear_has_payload();
    ::usb::comm::RgbIndicator* temp = _impl_.payload_.rgb_indicator_;
    _impl_.payload_.rgb_indicator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_rgb_indicator(::usb::comm::RgbIndicator* rgb_indicator) {
  clear_payload();
  if (rgb_indicator) {
    set_has_rgb_indicator();
    _impl_.payload_.rgb_indicator_ = rgb_indicator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.rgb_indicator)
}
inline ::usb::comm::RgbIndicator* MessageD2H::_internal_mutable_rgb_indicator() {
  if (!_internal_has_rgb_indicator()) {
    clear_payload();
    set_has_rgb_indicator();
    _impl_.payload_.rgb_indicator_ = CreateMaybeMessage< ::usb::comm::RgbIndicator >(GetArenaForAllocation());
  }
  return _impl_.payload_.rgb_indicator_;
}
inline ::usb::comm::RgbIndicator* MessageD2H::mutable_rgb_indicator() {
  ::usb::comm::RgbIndicator* _msg = _internal_mutable_rgb_indicator();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.rgb_indicator)
  return _msg;
}

// .usb.comm.EinkImage eink_image = 7;
inline bool MessageD2H::_internal_has_eink_image() const {
  return payload_case() == kEinkImage;
}
inline bool MessageD2H::has_eink_image() const {
  return _internal_has_eink_image();
}
inline void MessageD2H::set_has_eink_image() {
  _impl_._oneof_case_[0] = kEinkImage;
}
inline void MessageD2H::clear_eink_image() {
  if (_internal_has_eink_image()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.eink_image_;
    }
    clear_has_payload();
  }
}
inline ::usb::comm::EinkImage* MessageD2H::release_eink_image() {
  // @@protoc_insertion_point(field_release:usb.comm.MessageD2H.eink_image)
  if (_internal_has_eink_image()) {
    clear_has_payload();
    ::usb::comm::EinkImage* temp = _impl_.payload_.eink_image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.eink_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::usb::comm::EinkImage& MessageD2H::_internal_eink_image() const {
  return _internal_has_eink_image()
      ? *_impl_.payload_.eink_image_
      : reinterpret_cast< ::usb::comm::EinkImage&>(::usb::comm::_EinkImage_default_instance_);
}
inline const ::usb::comm::EinkImage& MessageD2H::eink_image() const {
  // @@protoc_insertion_point(field_get:usb.comm.MessageD2H.eink_image)
  return _internal_eink_image();
}
inline ::usb::comm::EinkImage* MessageD2H::unsafe_arena_release_eink_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:usb.comm.MessageD2H.eink_image)
  if (_internal_has_eink_image()) {
    clear_has_payload();
    ::usb::comm::EinkImage* temp = _impl_.payload_.eink_image_;
    _impl_.payload_.eink_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageD2H::unsafe_arena_set_allocated_eink_image(::usb::comm::EinkImage* eink_image) {
  clear_payload();
  if (eink_image) {
    set_has_eink_image();
    _impl_.payload_.eink_image_ = eink_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.MessageD2H.eink_image)
}
inline ::usb::comm::EinkImage* MessageD2H::_internal_mutable_eink_image() {
  if (!_internal_has_eink_image()) {
    clear_payload();
    set_has_eink_image();
    _impl_.payload_.eink_image_ = CreateMaybeMessage< ::usb::comm::EinkImage >(GetArenaForAllocation());
  }
  return _impl_.payload_.eink_image_;
}
inline ::usb::comm::EinkImage* MessageD2H::mutable_eink_image() {
  ::usb::comm::EinkImage* _msg = _internal_mutable_eink_image();
  // @@protoc_insertion_point(field_mutable:usb.comm.MessageD2H.eink_image)
  return _msg;
}

inline bool MessageD2H::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MessageD2H::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MessageD2H::PayloadCase MessageD2H::payload_case() const {
  return MessageD2H::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Nop

// -------------------------------------------------------------------

// Version_Features

// optional bool rgb = 1;
inline bool Version_Features::_internal_has_rgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Version_Features::has_rgb() const {
  return _internal_has_rgb();
}
inline void Version_Features::clear_rgb() {
  _impl_.rgb_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Version_Features::_internal_rgb() const {
  return _impl_.rgb_;
}
inline bool Version_Features::rgb() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.Features.rgb)
  return _internal_rgb();
}
inline void Version_Features::_internal_set_rgb(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rgb_ = value;
}
inline void Version_Features::set_rgb(bool value) {
  _internal_set_rgb(value);
  // @@protoc_insertion_point(field_set:usb.comm.Version.Features.rgb)
}

// optional bool rgb_full_control = 5;
inline bool Version_Features::_internal_has_rgb_full_control() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Version_Features::has_rgb_full_control() const {
  return _internal_has_rgb_full_control();
}
inline void Version_Features::clear_rgb_full_control() {
  _impl_.rgb_full_control_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Version_Features::_internal_rgb_full_control() const {
  return _impl_.rgb_full_control_;
}
inline bool Version_Features::rgb_full_control() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.Features.rgb_full_control)
  return _internal_rgb_full_control();
}
inline void Version_Features::_internal_set_rgb_full_control(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rgb_full_control_ = value;
}
inline void Version_Features::set_rgb_full_control(bool value) {
  _internal_set_rgb_full_control(value);
  // @@protoc_insertion_point(field_set:usb.comm.Version.Features.rgb_full_control)
}

// optional bool rgb_indicator = 6;
inline bool Version_Features::_internal_has_rgb_indicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Version_Features::has_rgb_indicator() const {
  return _internal_has_rgb_indicator();
}
inline void Version_Features::clear_rgb_indicator() {
  _impl_.rgb_indicator_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Version_Features::_internal_rgb_indicator() const {
  return _impl_.rgb_indicator_;
}
inline bool Version_Features::rgb_indicator() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.Features.rgb_indicator)
  return _internal_rgb_indicator();
}
inline void Version_Features::_internal_set_rgb_indicator(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rgb_indicator_ = value;
}
inline void Version_Features::set_rgb_indicator(bool value) {
  _internal_set_rgb_indicator(value);
  // @@protoc_insertion_point(field_set:usb.comm.Version.Features.rgb_indicator)
}

// optional bool eink = 2;
inline bool Version_Features::_internal_has_eink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Version_Features::has_eink() const {
  return _internal_has_eink();
}
inline void Version_Features::clear_eink() {
  _impl_.eink_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Version_Features::_internal_eink() const {
  return _impl_.eink_;
}
inline bool Version_Features::eink() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.Features.eink)
  return _internal_eink();
}
inline void Version_Features::_internal_set_eink(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.eink_ = value;
}
inline void Version_Features::set_eink(bool value) {
  _internal_set_eink(value);
  // @@protoc_insertion_point(field_set:usb.comm.Version.Features.eink)
}

// optional bool knob = 3;
inline bool Version_Features::_internal_has_knob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Version_Features::has_knob() const {
  return _internal_has_knob();
}
inline void Version_Features::clear_knob() {
  _impl_.knob_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Version_Features::_internal_knob() const {
  return _impl_.knob_;
}
inline bool Version_Features::knob() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.Features.knob)
  return _internal_knob();
}
inline void Version_Features::_internal_set_knob(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.knob_ = value;
}
inline void Version_Features::set_knob(bool value) {
  _internal_set_knob(value);
  // @@protoc_insertion_point(field_set:usb.comm.Version.Features.knob)
}

// optional bool knob_prefs = 4;
inline bool Version_Features::_internal_has_knob_prefs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Version_Features::has_knob_prefs() const {
  return _internal_has_knob_prefs();
}
inline void Version_Features::clear_knob_prefs() {
  _impl_.knob_prefs_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Version_Features::_internal_knob_prefs() const {
  return _impl_.knob_prefs_;
}
inline bool Version_Features::knob_prefs() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.Features.knob_prefs)
  return _internal_knob_prefs();
}
inline void Version_Features::_internal_set_knob_prefs(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.knob_prefs_ = value;
}
inline void Version_Features::set_knob_prefs(bool value) {
  _internal_set_knob_prefs(value);
  // @@protoc_insertion_point(field_set:usb.comm.Version.Features.knob_prefs)
}

// -------------------------------------------------------------------

// Version

// required string zephyr_version = 1;
inline bool Version::_internal_has_zephyr_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Version::has_zephyr_version() const {
  return _internal_has_zephyr_version();
}
inline void Version::clear_zephyr_version() {
  _impl_.zephyr_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Version::zephyr_version() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.zephyr_version)
  return _internal_zephyr_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_zephyr_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.zephyr_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:usb.comm.Version.zephyr_version)
}
inline std::string* Version::mutable_zephyr_version() {
  std::string* _s = _internal_mutable_zephyr_version();
  // @@protoc_insertion_point(field_mutable:usb.comm.Version.zephyr_version)
  return _s;
}
inline const std::string& Version::_internal_zephyr_version() const {
  return _impl_.zephyr_version_.Get();
}
inline void Version::_internal_set_zephyr_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.zephyr_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_zephyr_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.zephyr_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_zephyr_version() {
  // @@protoc_insertion_point(field_release:usb.comm.Version.zephyr_version)
  if (!_internal_has_zephyr_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.zephyr_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zephyr_version_.IsDefault()) {
    _impl_.zephyr_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Version::set_allocated_zephyr_version(std::string* zephyr_version) {
  if (zephyr_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.zephyr_version_.SetAllocated(zephyr_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zephyr_version_.IsDefault()) {
    _impl_.zephyr_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:usb.comm.Version.zephyr_version)
}

// required string zmk_version = 2;
inline bool Version::_internal_has_zmk_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Version::has_zmk_version() const {
  return _internal_has_zmk_version();
}
inline void Version::clear_zmk_version() {
  _impl_.zmk_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Version::zmk_version() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.zmk_version)
  return _internal_zmk_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_zmk_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.zmk_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:usb.comm.Version.zmk_version)
}
inline std::string* Version::mutable_zmk_version() {
  std::string* _s = _internal_mutable_zmk_version();
  // @@protoc_insertion_point(field_mutable:usb.comm.Version.zmk_version)
  return _s;
}
inline const std::string& Version::_internal_zmk_version() const {
  return _impl_.zmk_version_.Get();
}
inline void Version::_internal_set_zmk_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.zmk_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_zmk_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.zmk_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_zmk_version() {
  // @@protoc_insertion_point(field_release:usb.comm.Version.zmk_version)
  if (!_internal_has_zmk_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.zmk_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zmk_version_.IsDefault()) {
    _impl_.zmk_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Version::set_allocated_zmk_version(std::string* zmk_version) {
  if (zmk_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.zmk_version_.SetAllocated(zmk_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zmk_version_.IsDefault()) {
    _impl_.zmk_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:usb.comm.Version.zmk_version)
}

// required string app_version = 3;
inline bool Version::_internal_has_app_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Version::has_app_version() const {
  return _internal_has_app_version();
}
inline void Version::clear_app_version() {
  _impl_.app_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Version::app_version() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.app_version)
  return _internal_app_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_app_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.app_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:usb.comm.Version.app_version)
}
inline std::string* Version::mutable_app_version() {
  std::string* _s = _internal_mutable_app_version();
  // @@protoc_insertion_point(field_mutable:usb.comm.Version.app_version)
  return _s;
}
inline const std::string& Version::_internal_app_version() const {
  return _impl_.app_version_.Get();
}
inline void Version::_internal_set_app_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_app_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.app_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_app_version() {
  // @@protoc_insertion_point(field_release:usb.comm.Version.app_version)
  if (!_internal_has_app_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.app_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_version_.IsDefault()) {
    _impl_.app_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Version::set_allocated_app_version(std::string* app_version) {
  if (app_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.app_version_.SetAllocated(app_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_version_.IsDefault()) {
    _impl_.app_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:usb.comm.Version.app_version)
}

// optional .usb.comm.Version.Features features = 4;
inline bool Version::_internal_has_features() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.features_ != nullptr);
  return value;
}
inline bool Version::has_features() const {
  return _internal_has_features();
}
inline void Version::clear_features() {
  if (_impl_.features_ != nullptr) _impl_.features_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::usb::comm::Version_Features& Version::_internal_features() const {
  const ::usb::comm::Version_Features* p = _impl_.features_;
  return p != nullptr ? *p : reinterpret_cast<const ::usb::comm::Version_Features&>(
      ::usb::comm::_Version_Features_default_instance_);
}
inline const ::usb::comm::Version_Features& Version::features() const {
  // @@protoc_insertion_point(field_get:usb.comm.Version.features)
  return _internal_features();
}
inline void Version::unsafe_arena_set_allocated_features(
    ::usb::comm::Version_Features* features) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.features_);
  }
  _impl_.features_ = features;
  if (features) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.Version.features)
}
inline ::usb::comm::Version_Features* Version::release_features() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::usb::comm::Version_Features* temp = _impl_.features_;
  _impl_.features_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::usb::comm::Version_Features* Version::unsafe_arena_release_features() {
  // @@protoc_insertion_point(field_release:usb.comm.Version.features)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::usb::comm::Version_Features* temp = _impl_.features_;
  _impl_.features_ = nullptr;
  return temp;
}
inline ::usb::comm::Version_Features* Version::_internal_mutable_features() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.features_ == nullptr) {
    auto* p = CreateMaybeMessage<::usb::comm::Version_Features>(GetArenaForAllocation());
    _impl_.features_ = p;
  }
  return _impl_.features_;
}
inline ::usb::comm::Version_Features* Version::mutable_features() {
  ::usb::comm::Version_Features* _msg = _internal_mutable_features();
  // @@protoc_insertion_point(field_mutable:usb.comm.Version.features)
  return _msg;
}
inline void Version::set_allocated_features(::usb::comm::Version_Features* features) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.features_;
  }
  if (features) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(features);
    if (message_arena != submessage_arena) {
      features = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, features, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.features_ = features;
  // @@protoc_insertion_point(field_set_allocated:usb.comm.Version.features)
}

// -------------------------------------------------------------------

// MotorState

// required uint32 timestamp = 1;
inline bool MotorState::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotorState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void MotorState::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MotorState::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t MotorState::timestamp() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.timestamp)
  return _internal_timestamp();
}
inline void MotorState::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void MotorState::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.timestamp)
}

// required .usb.comm.MotorState.ControlMode control_mode = 2;
inline bool MotorState::_internal_has_control_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotorState::has_control_mode() const {
  return _internal_has_control_mode();
}
inline void MotorState::clear_control_mode() {
  _impl_.control_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::usb::comm::MotorState_ControlMode MotorState::_internal_control_mode() const {
  return static_cast< ::usb::comm::MotorState_ControlMode >(_impl_.control_mode_);
}
inline ::usb::comm::MotorState_ControlMode MotorState::control_mode() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.control_mode)
  return _internal_control_mode();
}
inline void MotorState::_internal_set_control_mode(::usb::comm::MotorState_ControlMode value) {
  assert(::usb::comm::MotorState_ControlMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.control_mode_ = value;
}
inline void MotorState::set_control_mode(::usb::comm::MotorState_ControlMode value) {
  _internal_set_control_mode(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.control_mode)
}

// required float current_angle = 3;
inline bool MotorState::_internal_has_current_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotorState::has_current_angle() const {
  return _internal_has_current_angle();
}
inline void MotorState::clear_current_angle() {
  _impl_.current_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float MotorState::_internal_current_angle() const {
  return _impl_.current_angle_;
}
inline float MotorState::current_angle() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.current_angle)
  return _internal_current_angle();
}
inline void MotorState::_internal_set_current_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.current_angle_ = value;
}
inline void MotorState::set_current_angle(float value) {
  _internal_set_current_angle(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.current_angle)
}

// required float current_velocity = 4;
inline bool MotorState::_internal_has_current_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotorState::has_current_velocity() const {
  return _internal_has_current_velocity();
}
inline void MotorState::clear_current_velocity() {
  _impl_.current_velocity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MotorState::_internal_current_velocity() const {
  return _impl_.current_velocity_;
}
inline float MotorState::current_velocity() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.current_velocity)
  return _internal_current_velocity();
}
inline void MotorState::_internal_set_current_velocity(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.current_velocity_ = value;
}
inline void MotorState::set_current_velocity(float value) {
  _internal_set_current_velocity(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.current_velocity)
}

// required float target_angle = 5;
inline bool MotorState::_internal_has_target_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotorState::has_target_angle() const {
  return _internal_has_target_angle();
}
inline void MotorState::clear_target_angle() {
  _impl_.target_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float MotorState::_internal_target_angle() const {
  return _impl_.target_angle_;
}
inline float MotorState::target_angle() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.target_angle)
  return _internal_target_angle();
}
inline void MotorState::_internal_set_target_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_angle_ = value;
}
inline void MotorState::set_target_angle(float value) {
  _internal_set_target_angle(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.target_angle)
}

// required float target_velocity = 6;
inline bool MotorState::_internal_has_target_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MotorState::has_target_velocity() const {
  return _internal_has_target_velocity();
}
inline void MotorState::clear_target_velocity() {
  _impl_.target_velocity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float MotorState::_internal_target_velocity() const {
  return _impl_.target_velocity_;
}
inline float MotorState::target_velocity() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.target_velocity)
  return _internal_target_velocity();
}
inline void MotorState::_internal_set_target_velocity(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.target_velocity_ = value;
}
inline void MotorState::set_target_velocity(float value) {
  _internal_set_target_velocity(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.target_velocity)
}

// required float target_voltage = 7;
inline bool MotorState::_internal_has_target_voltage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MotorState::has_target_voltage() const {
  return _internal_has_target_voltage();
}
inline void MotorState::clear_target_voltage() {
  _impl_.target_voltage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float MotorState::_internal_target_voltage() const {
  return _impl_.target_voltage_;
}
inline float MotorState::target_voltage() const {
  // @@protoc_insertion_point(field_get:usb.comm.MotorState.target_voltage)
  return _internal_target_voltage();
}
inline void MotorState::_internal_set_target_voltage(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.target_voltage_ = value;
}
inline void MotorState::set_target_voltage(float value) {
  _internal_set_target_voltage(value);
  // @@protoc_insertion_point(field_set:usb.comm.MotorState.target_voltage)
}

// -------------------------------------------------------------------

// KnobConfig_Pref

// required uint32 layer_id = 1;
inline bool KnobConfig_Pref::_internal_has_layer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KnobConfig_Pref::has_layer_id() const {
  return _internal_has_layer_id();
}
inline void KnobConfig_Pref::clear_layer_id() {
  _impl_.layer_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t KnobConfig_Pref::_internal_layer_id() const {
  return _impl_.layer_id_;
}
inline uint32_t KnobConfig_Pref::layer_id() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.Pref.layer_id)
  return _internal_layer_id();
}
inline void KnobConfig_Pref::_internal_set_layer_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.layer_id_ = value;
}
inline void KnobConfig_Pref::set_layer_id(uint32_t value) {
  _internal_set_layer_id(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.Pref.layer_id)
}

// optional string layer_name = 2;
inline bool KnobConfig_Pref::_internal_has_layer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KnobConfig_Pref::has_layer_name() const {
  return _internal_has_layer_name();
}
inline void KnobConfig_Pref::clear_layer_name() {
  _impl_.layer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KnobConfig_Pref::layer_name() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.Pref.layer_name)
  return _internal_layer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KnobConfig_Pref::set_layer_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.layer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.Pref.layer_name)
}
inline std::string* KnobConfig_Pref::mutable_layer_name() {
  std::string* _s = _internal_mutable_layer_name();
  // @@protoc_insertion_point(field_mutable:usb.comm.KnobConfig.Pref.layer_name)
  return _s;
}
inline const std::string& KnobConfig_Pref::_internal_layer_name() const {
  return _impl_.layer_name_.Get();
}
inline void KnobConfig_Pref::_internal_set_layer_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.layer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* KnobConfig_Pref::_internal_mutable_layer_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.layer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* KnobConfig_Pref::release_layer_name() {
  // @@protoc_insertion_point(field_release:usb.comm.KnobConfig.Pref.layer_name)
  if (!_internal_has_layer_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.layer_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layer_name_.IsDefault()) {
    _impl_.layer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KnobConfig_Pref::set_allocated_layer_name(std::string* layer_name) {
  if (layer_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.layer_name_.SetAllocated(layer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layer_name_.IsDefault()) {
    _impl_.layer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:usb.comm.KnobConfig.Pref.layer_name)
}

// required bool active = 3;
inline bool KnobConfig_Pref::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KnobConfig_Pref::has_active() const {
  return _internal_has_active();
}
inline void KnobConfig_Pref::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool KnobConfig_Pref::_internal_active() const {
  return _impl_.active_;
}
inline bool KnobConfig_Pref::active() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.Pref.active)
  return _internal_active();
}
inline void KnobConfig_Pref::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.active_ = value;
}
inline void KnobConfig_Pref::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.Pref.active)
}

// optional .usb.comm.KnobConfig.Mode mode = 4;
inline bool KnobConfig_Pref::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KnobConfig_Pref::has_mode() const {
  return _internal_has_mode();
}
inline void KnobConfig_Pref::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::usb::comm::KnobConfig_Mode KnobConfig_Pref::_internal_mode() const {
  return static_cast< ::usb::comm::KnobConfig_Mode >(_impl_.mode_);
}
inline ::usb::comm::KnobConfig_Mode KnobConfig_Pref::mode() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.Pref.mode)
  return _internal_mode();
}
inline void KnobConfig_Pref::_internal_set_mode(::usb::comm::KnobConfig_Mode value) {
  assert(::usb::comm::KnobConfig_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mode_ = value;
}
inline void KnobConfig_Pref::set_mode(::usb::comm::KnobConfig_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.Pref.mode)
}

// optional uint32 ppr = 5;
inline bool KnobConfig_Pref::_internal_has_ppr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool KnobConfig_Pref::has_ppr() const {
  return _internal_has_ppr();
}
inline void KnobConfig_Pref::clear_ppr() {
  _impl_.ppr_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t KnobConfig_Pref::_internal_ppr() const {
  return _impl_.ppr_;
}
inline uint32_t KnobConfig_Pref::ppr() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.Pref.ppr)
  return _internal_ppr();
}
inline void KnobConfig_Pref::_internal_set_ppr(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ppr_ = value;
}
inline void KnobConfig_Pref::set_ppr(uint32_t value) {
  _internal_set_ppr(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.Pref.ppr)
}

// optional float torque_limit = 6;
inline bool KnobConfig_Pref::_internal_has_torque_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool KnobConfig_Pref::has_torque_limit() const {
  return _internal_has_torque_limit();
}
inline void KnobConfig_Pref::clear_torque_limit() {
  _impl_.torque_limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float KnobConfig_Pref::_internal_torque_limit() const {
  return _impl_.torque_limit_;
}
inline float KnobConfig_Pref::torque_limit() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.Pref.torque_limit)
  return _internal_torque_limit();
}
inline void KnobConfig_Pref::_internal_set_torque_limit(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.torque_limit_ = value;
}
inline void KnobConfig_Pref::set_torque_limit(float value) {
  _internal_set_torque_limit(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.Pref.torque_limit)
}

// -------------------------------------------------------------------

// KnobConfig

// required bool demo = 1;
inline bool KnobConfig::_internal_has_demo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KnobConfig::has_demo() const {
  return _internal_has_demo();
}
inline void KnobConfig::clear_demo() {
  _impl_.demo_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool KnobConfig::_internal_demo() const {
  return _impl_.demo_;
}
inline bool KnobConfig::demo() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.demo)
  return _internal_demo();
}
inline void KnobConfig::_internal_set_demo(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.demo_ = value;
}
inline void KnobConfig::set_demo(bool value) {
  _internal_set_demo(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.demo)
}

// required .usb.comm.KnobConfig.Mode mode = 2;
inline bool KnobConfig::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KnobConfig::has_mode() const {
  return _internal_has_mode();
}
inline void KnobConfig::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::usb::comm::KnobConfig_Mode KnobConfig::_internal_mode() const {
  return static_cast< ::usb::comm::KnobConfig_Mode >(_impl_.mode_);
}
inline ::usb::comm::KnobConfig_Mode KnobConfig::mode() const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.mode)
  return _internal_mode();
}
inline void KnobConfig::_internal_set_mode(::usb::comm::KnobConfig_Mode value) {
  assert(::usb::comm::KnobConfig_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mode_ = value;
}
inline void KnobConfig::set_mode(::usb::comm::KnobConfig_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:usb.comm.KnobConfig.mode)
}

// repeated .usb.comm.KnobConfig.Pref prefs = 5;
inline int KnobConfig::_internal_prefs_size() const {
  return _impl_.prefs_.size();
}
inline int KnobConfig::prefs_size() const {
  return _internal_prefs_size();
}
inline void KnobConfig::clear_prefs() {
  _impl_.prefs_.Clear();
}
inline ::usb::comm::KnobConfig_Pref* KnobConfig::mutable_prefs(int index) {
  // @@protoc_insertion_point(field_mutable:usb.comm.KnobConfig.prefs)
  return _impl_.prefs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::usb::comm::KnobConfig_Pref >*
KnobConfig::mutable_prefs() {
  // @@protoc_insertion_point(field_mutable_list:usb.comm.KnobConfig.prefs)
  return &_impl_.prefs_;
}
inline const ::usb::comm::KnobConfig_Pref& KnobConfig::_internal_prefs(int index) const {
  return _impl_.prefs_.Get(index);
}
inline const ::usb::comm::KnobConfig_Pref& KnobConfig::prefs(int index) const {
  // @@protoc_insertion_point(field_get:usb.comm.KnobConfig.prefs)
  return _internal_prefs(index);
}
inline ::usb::comm::KnobConfig_Pref* KnobConfig::_internal_add_prefs() {
  return _impl_.prefs_.Add();
}
inline ::usb::comm::KnobConfig_Pref* KnobConfig::add_prefs() {
  ::usb::comm::KnobConfig_Pref* _add = _internal_add_prefs();
  // @@protoc_insertion_point(field_add:usb.comm.KnobConfig.prefs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::usb::comm::KnobConfig_Pref >&
KnobConfig::prefs() const {
  // @@protoc_insertion_point(field_list:usb.comm.KnobConfig.prefs)
  return _impl_.prefs_;
}

// -------------------------------------------------------------------

// RgbControl

// required .usb.comm.RgbControl.Command command = 1;
inline bool RgbControl::_internal_has_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RgbControl::has_command() const {
  return _internal_has_command();
}
inline void RgbControl::clear_command() {
  _impl_.command_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::usb::comm::RgbControl_Command RgbControl::_internal_command() const {
  return static_cast< ::usb::comm::RgbControl_Command >(_impl_.command_);
}
inline ::usb::comm::RgbControl_Command RgbControl::command() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbControl.command)
  return _internal_command();
}
inline void RgbControl::_internal_set_command(::usb::comm::RgbControl_Command value) {
  assert(::usb::comm::RgbControl_Command_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.command_ = value;
}
inline void RgbControl::set_command(::usb::comm::RgbControl_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbControl.command)
}

// -------------------------------------------------------------------

// RgbState_HSB

// required uint32 h = 1;
inline bool RgbState_HSB::_internal_has_h() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RgbState_HSB::has_h() const {
  return _internal_has_h();
}
inline void RgbState_HSB::clear_h() {
  _impl_.h_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RgbState_HSB::_internal_h() const {
  return _impl_.h_;
}
inline uint32_t RgbState_HSB::h() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.HSB.h)
  return _internal_h();
}
inline void RgbState_HSB::_internal_set_h(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.h_ = value;
}
inline void RgbState_HSB::set_h(uint32_t value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbState.HSB.h)
}

// required uint32 s = 2;
inline bool RgbState_HSB::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RgbState_HSB::has_s() const {
  return _internal_has_s();
}
inline void RgbState_HSB::clear_s() {
  _impl_.s_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RgbState_HSB::_internal_s() const {
  return _impl_.s_;
}
inline uint32_t RgbState_HSB::s() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.HSB.s)
  return _internal_s();
}
inline void RgbState_HSB::_internal_set_s(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s_ = value;
}
inline void RgbState_HSB::set_s(uint32_t value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbState.HSB.s)
}

// required uint32 b = 3;
inline bool RgbState_HSB::_internal_has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RgbState_HSB::has_b() const {
  return _internal_has_b();
}
inline void RgbState_HSB::clear_b() {
  _impl_.b_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RgbState_HSB::_internal_b() const {
  return _impl_.b_;
}
inline uint32_t RgbState_HSB::b() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.HSB.b)
  return _internal_b();
}
inline void RgbState_HSB::_internal_set_b(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.b_ = value;
}
inline void RgbState_HSB::set_b(uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbState.HSB.b)
}

// -------------------------------------------------------------------

// RgbState

// required bool on = 1;
inline bool RgbState::_internal_has_on() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RgbState::has_on() const {
  return _internal_has_on();
}
inline void RgbState::clear_on() {
  _impl_.on_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RgbState::_internal_on() const {
  return _impl_.on_;
}
inline bool RgbState::on() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.on)
  return _internal_on();
}
inline void RgbState::_internal_set_on(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.on_ = value;
}
inline void RgbState::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbState.on)
}

// optional .usb.comm.RgbState.HSB color = 2;
inline bool RgbState::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool RgbState::has_color() const {
  return _internal_has_color();
}
inline void RgbState::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::usb::comm::RgbState_HSB& RgbState::_internal_color() const {
  const ::usb::comm::RgbState_HSB* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::usb::comm::RgbState_HSB&>(
      ::usb::comm::_RgbState_HSB_default_instance_);
}
inline const ::usb::comm::RgbState_HSB& RgbState::color() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.color)
  return _internal_color();
}
inline void RgbState::unsafe_arena_set_allocated_color(
    ::usb::comm::RgbState_HSB* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usb.comm.RgbState.color)
}
inline ::usb::comm::RgbState_HSB* RgbState::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::usb::comm::RgbState_HSB* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::usb::comm::RgbState_HSB* RgbState::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:usb.comm.RgbState.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::usb::comm::RgbState_HSB* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::usb::comm::RgbState_HSB* RgbState::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::usb::comm::RgbState_HSB>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::usb::comm::RgbState_HSB* RgbState::mutable_color() {
  ::usb::comm::RgbState_HSB* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:usb.comm.RgbState.color)
  return _msg;
}
inline void RgbState::set_allocated_color(::usb::comm::RgbState_HSB* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:usb.comm.RgbState.color)
}

// optional .usb.comm.RgbState.Effect effect = 3;
inline bool RgbState::_internal_has_effect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RgbState::has_effect() const {
  return _internal_has_effect();
}
inline void RgbState::clear_effect() {
  _impl_.effect_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::usb::comm::RgbState_Effect RgbState::_internal_effect() const {
  return static_cast< ::usb::comm::RgbState_Effect >(_impl_.effect_);
}
inline ::usb::comm::RgbState_Effect RgbState::effect() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.effect)
  return _internal_effect();
}
inline void RgbState::_internal_set_effect(::usb::comm::RgbState_Effect value) {
  assert(::usb::comm::RgbState_Effect_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.effect_ = value;
}
inline void RgbState::set_effect(::usb::comm::RgbState_Effect value) {
  _internal_set_effect(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbState.effect)
}

// optional uint32 speed = 4;
inline bool RgbState::_internal_has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RgbState::has_speed() const {
  return _internal_has_speed();
}
inline void RgbState::clear_speed() {
  _impl_.speed_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RgbState::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t RgbState::speed() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbState.speed)
  return _internal_speed();
}
inline void RgbState::_internal_set_speed(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.speed_ = value;
}
inline void RgbState::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbState.speed)
}

// -------------------------------------------------------------------

// RgbIndicator

// optional bool enable = 1;
inline bool RgbIndicator::_internal_has_enable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RgbIndicator::has_enable() const {
  return _internal_has_enable();
}
inline void RgbIndicator::clear_enable() {
  _impl_.enable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RgbIndicator::_internal_enable() const {
  return _impl_.enable_;
}
inline bool RgbIndicator::enable() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbIndicator.enable)
  return _internal_enable();
}
inline void RgbIndicator::_internal_set_enable(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_ = value;
}
inline void RgbIndicator::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbIndicator.enable)
}

// optional uint32 brightness_active = 2;
inline bool RgbIndicator::_internal_has_brightness_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RgbIndicator::has_brightness_active() const {
  return _internal_has_brightness_active();
}
inline void RgbIndicator::clear_brightness_active() {
  _impl_.brightness_active_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RgbIndicator::_internal_brightness_active() const {
  return _impl_.brightness_active_;
}
inline uint32_t RgbIndicator::brightness_active() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbIndicator.brightness_active)
  return _internal_brightness_active();
}
inline void RgbIndicator::_internal_set_brightness_active(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.brightness_active_ = value;
}
inline void RgbIndicator::set_brightness_active(uint32_t value) {
  _internal_set_brightness_active(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbIndicator.brightness_active)
}

// optional uint32 brightness_inactive = 3;
inline bool RgbIndicator::_internal_has_brightness_inactive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RgbIndicator::has_brightness_inactive() const {
  return _internal_has_brightness_inactive();
}
inline void RgbIndicator::clear_brightness_inactive() {
  _impl_.brightness_inactive_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RgbIndicator::_internal_brightness_inactive() const {
  return _impl_.brightness_inactive_;
}
inline uint32_t RgbIndicator::brightness_inactive() const {
  // @@protoc_insertion_point(field_get:usb.comm.RgbIndicator.brightness_inactive)
  return _internal_brightness_inactive();
}
inline void RgbIndicator::_internal_set_brightness_inactive(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.brightness_inactive_ = value;
}
inline void RgbIndicator::set_brightness_inactive(uint32_t value) {
  _internal_set_brightness_inactive(value);
  // @@protoc_insertion_point(field_set:usb.comm.RgbIndicator.brightness_inactive)
}

// -------------------------------------------------------------------

// EinkImage

// required uint32 id = 1;
inline bool EinkImage::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EinkImage::has_id() const {
  return _internal_has_id();
}
inline void EinkImage::clear_id() {
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t EinkImage::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t EinkImage::id() const {
  // @@protoc_insertion_point(field_get:usb.comm.EinkImage.id)
  return _internal_id();
}
inline void EinkImage::_internal_set_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void EinkImage::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:usb.comm.EinkImage.id)
}

// optional uint32 bits_length = 2 [deprecated = true];
inline bool EinkImage::_internal_has_bits_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EinkImage::has_bits_length() const {
  return _internal_has_bits_length();
}
inline void EinkImage::clear_bits_length() {
  _impl_.bits_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t EinkImage::_internal_bits_length() const {
  return _impl_.bits_length_;
}
inline uint32_t EinkImage::bits_length() const {
  // @@protoc_insertion_point(field_get:usb.comm.EinkImage.bits_length)
  return _internal_bits_length();
}
inline void EinkImage::_internal_set_bits_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bits_length_ = value;
}
inline void EinkImage::set_bits_length(uint32_t value) {
  _internal_set_bits_length(value);
  // @@protoc_insertion_point(field_set:usb.comm.EinkImage.bits_length)
}

// optional bytes bits = 3;
inline bool EinkImage::_internal_has_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EinkImage::has_bits() const {
  return _internal_has_bits();
}
inline void EinkImage::clear_bits() {
  _impl_.bits_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EinkImage::bits() const {
  // @@protoc_insertion_point(field_get:usb.comm.EinkImage.bits)
  return _internal_bits();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EinkImage::set_bits(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.bits_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:usb.comm.EinkImage.bits)
}
inline std::string* EinkImage::mutable_bits() {
  std::string* _s = _internal_mutable_bits();
  // @@protoc_insertion_point(field_mutable:usb.comm.EinkImage.bits)
  return _s;
}
inline const std::string& EinkImage::_internal_bits() const {
  return _impl_.bits_.Get();
}
inline void EinkImage::_internal_set_bits(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bits_.Set(value, GetArenaForAllocation());
}
inline std::string* EinkImage::_internal_mutable_bits() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.bits_.Mutable(GetArenaForAllocation());
}
inline std::string* EinkImage::release_bits() {
  // @@protoc_insertion_point(field_release:usb.comm.EinkImage.bits)
  if (!_internal_has_bits()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.bits_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bits_.IsDefault()) {
    _impl_.bits_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EinkImage::set_allocated_bits(std::string* bits) {
  if (bits != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bits_.SetAllocated(bits, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bits_.IsDefault()) {
    _impl_.bits_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:usb.comm.EinkImage.bits)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace comm
}  // namespace usb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::usb::comm::MotorState_ControlMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usb::comm::MotorState_ControlMode>() {
  return ::usb::comm::MotorState_ControlMode_descriptor();
}
template <> struct is_proto_enum< ::usb::comm::KnobConfig_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usb::comm::KnobConfig_Mode>() {
  return ::usb::comm::KnobConfig_Mode_descriptor();
}
template <> struct is_proto_enum< ::usb::comm::RgbControl_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usb::comm::RgbControl_Command>() {
  return ::usb::comm::RgbControl_Command_descriptor();
}
template <> struct is_proto_enum< ::usb::comm::RgbState_Effect> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usb::comm::RgbState_Effect>() {
  return ::usb::comm::RgbState_Effect_descriptor();
}
template <> struct is_proto_enum< ::usb::comm::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usb::comm::Action>() {
  return ::usb::comm::Action_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_usb_5fcomm_2eproto
